<!doctype html>
<html>
	<head>
		<title>jsPlumb - documentation</title>
		<link rel="stylesheet" href="../css/jsPlumbDemo.css"></link>
		<link rel="stylesheet" href="/mp.css"></link>
	</head>
	<body>	
		<div class="menu"><a href="../html/demo.html" class="mplink">view demo</a>&nbsp;|&nbsp;<a href="mailto:simon.porritt@gmail.com" class="mplink">contact me</a></div>
	
	<div class="section">
			<h3>Index</h3>
			<ul>
				<li><a href="#summary">Summary</a></li>
				<li><a href="#basic">Basic Configuration</a></li>
				<li><a href="#changes">Changes between 0.0.3 and 0.0.4-RCx</a></li>
				<li><a href="#examples">Examples</a></li>
				<li><a href="#options">Options</a></li>
				<li><a href="#defaults">Defaults</a></li>
				<li><a href="#anchors">Anchors</a></li>
				<li><a href="#connectors">Connectors</a></li>
				<li><a href="#endpoints">Endpoints</a></li>
				<li><a href="#gradients">Gradients</a></li>
				<li><a href="#cssclasses">CSS Class Reference</a></li>
				<li><a href="#enhancements">Future Enhancements</a></li>
			</ul>
			<strong>This document refers to release 0.0.4-RC5 of jsPlumb.</strong>
		</div>
	
		<div class="section">
			<a id="summary"><h3>Summary</h3></a>
			jsPlumb allows you to connect elements on the screen with "plumbing", using a Canvas
			element when supported, and Google's <a class="mplink" href="http://excanvas.sourceforge.net/" target="_blank">ExplorerCanvas</a> script to support older browsers.
			<p>
			It's written as a jQuery plugin, and relies on jQuery 1.3.x or jQuery 1.4.x (tested on 1.3.2 and 1.4.2), and also jQuery UI 1.7.2 (if you want to support
			dragging).  For Canvas support in IE you also need to include Google's ExplorerCanvas script.
			</p>	
			<p>jsPlumb has been tested on the following browsers:
				<ul>
					<li>IE 6 on Windows XP</li>
					<li>IE 7 on Windows XP</li>
					<li>IE 8 on Windows XP (we force IE7 standards compatibility mode)</li>
					<li>Firefox 3.5.8 on Windows XP</li>
					<li>Firefox 3.6 on Ubuntu 9.10</li>
					<li>Firefox 3.6 on Windows XP</li>
					<li>Chrome on Ubuntu 9.10</li>
					<li>Safari 4 on Mac Tiger</li> 
					<li>Safari 4 on Windows XP</li>
					<li>Opera 10.5 on Windows XP</li>
				</ul>
			</p>		
		</div>
						
		<div class="section">						
			<a id="basic"><h3>Basic configuration</h3></a>
			To use jsPlumb you need jQuery 1.3.x or 1.4.x, jQueryUI 1.7.x, and ExplorerCanvas:
			<div class="code">
			<pre>&lt;script type="text/javascript" src="PATH_TO_EXPLORER_CANVAS_SCRIPT"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.7.2/jquery-ui.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="PATH_TO/jsPlumb-0.0.4-RC2.js "&gt;&lt;/script&gt;</pre>
			</div>
			<p>Please don't link to the excanvas.js script on the morrisonpitt.com server!  I'm just a struggling 
			web developer who needs to minimize his bandwidth.  You may wonder why it is not at ajax.googleapis.com - I 
			know I did.</p>
			The current released version of jsPlumb is 0.0.3; the demo site is running on 0.0.4-RC5 right now.  We intend to
			release 0.0.4 by the end of March 2010.			
		</div>
		
		<div class="section">						
			<a id="changes"><h3>Changes between 0.0.3 and 0.0.4-RCx</h3></a>
			In addition to introducing gradients for connectors, and fixing a bug or two, version 0.0.4 has made a few key API
			changes over 0.0.3:
			<ul>
				<li>all Connector and Endpoint implementations have been renamed so they're not so shouty.<br/><br/>
					<ul>
						<li>BEZIER -> Bezier</li>
						<li>STRAIGHT_LINE -> Straight</li>
						<li>DOT -> Dot</li>
						<li>RECTANGLE -> Rectangle</li>
					</ul>
					<p>
					This is easier on the eye.  We plan on altering Anchors in the same way at some stage before releasing 0.0.4.
					</p>
				</li>
				<li>all Connector and Endpoint implementations are no longer static.
					<p>
					Where once you could say:<br/><br/>
					{ ... connector: jsPlumb.Connectors.BEZIER ... }
					<br/><br/>
					you now must say:<br/><br/>
					{ ... connector: new jsPlumb.Connectors.Bezier() ... }
					</p>
					<p>
					This allows us to pass parameters in to customize things more easily.
					</p>
				</li>
				<li>The Bezier endpoint supports a 'curviness' parameter to change the basic shape of the connector.
				<p>
					See the <a href="#bezierConnector">Bezier connector</a> discussion for more details.
				</p>
				</li>
				<li>Connectors now support gradients.
					<p>See the <a href="#gradients">gradients</a> section for a discussion of this</p>
				</li>
				<li>The 'Straight' connector paints properly when the two anchors are in a straight line either horizontally or vertically (it used to be invisible)			
				</li>
			</ul>
		</div>
		
		<div class="section">						
			<a id="examples"><h3>Examples</h3></a>
			
			The basic syntax of a call is that you execute 'plumb' on some element, providing a target, and optionally a paintStyle and preferences for where you
			want the plumbing to be anchored on each element, as well as the type of connector to use:
			
			<ul>
				<li>Plumb window1 to window2 with the default settings:
					<div class="code">			
						<pre>$("#window1").plumb({target:'window2'});</pre>
					</div>
				</li>	
				<li>Plumb window1 to window2 with a 15 pixel wide yellow plumb line, and a slightly brighter endpoint: 			
					<div class="code">			
<pre>$("#window1").plumb({
	target:'window2', 
	paintStyle:{lineWidth:15,strokeStyle:'rgb(243,230,18)'}, 
	endpointStyle:{fillStyle:'rgb(243,229,0)'}
});</pre>
					</div>	
				</li>			
				<li>Plumb window3 to 'window4' with a 10 pixel wide, semi opaque blue plumb line, anchored to the left middle of window3, and the right middle of window4, with an endpoint of radius 25:			
					<div class="code">			
<pre>$("#window3").plumb({
	target:'window4', 
	paintStyle:{lineWidth:10, strokeStyle:'rgba(0, 0, 200, 0.5)'}, 
	anchors:[jsPlumb.Anchors.RIGHT_MIDDLE, jsPlumb.Anchors.LEFT_MIDDLE], 
	endpointStyle:{radius:25}
});</pre>
					</div>
				</li>			
				<li>Plumb window2 to window3 with a default plumb line from the top center of window2 to the bottom center of window3, and rectangular endpoints: 			
					<div class="code">			
<pre>$("#window2").plumb({
	target:'window3', 
	paintStyle:{lineWidth:8, strokeStyle:'rgb(189,11,11)'}, 
	anchors:[jsPlumb.Anchors.BOTTOM_CENTER, jsPlumb.Anchors.TOP_CENTER], 
	endpointType:new jsPlumb.Endpoints.Rectangle()
});</pre>
					</div>
				</li>			
				<li>Plumb window5 to window6 between their center points with a semi-opaque connector, and 125px endpoints:
					<div class="code">			
<pre>$("#window5").plumb({
	target:'window6', 
	anchors:[jsPlumb.Anchors.CENTER, jsPlumb.Anchors.CENTER], 
	paintStyle:{lineWidth:5,strokeStyle:'rgba(0,255,0,0.5)'}, 
	endpointsOnTop:false, 
	endpointStyle:{radius:125}
});</pre>
					</div>
				</li>			
				<li>Plumb window7 to window8 with a 10 pixel wide blue plumb line, anchored on the top left of window7 and the bottom right of window8, and
				   disable dragging (if any other plumb command enables dragging on either element this will be overridden):
					<div class="code">			
<pre>$("#window7").plumb({
	target:'window8', 
	paintStyle:{lineWidth:10, strokeStyle:'blue'}, 
	anchors:[jsPlumb.Anchors.TOP_LEFT, jsPlumb.Anchors.BOTTOM_RIGHT]
});</pre>
					</div>
				</li>			
				<li>Plumb the bottom right corner of window4 to the top left corner of window5, with rectangular endpoints of size 40x40 that appear below the content elements:
					<div class="code">
<pre>$("#window4").plumb({
	target:'window5', 
	anchors:[jsPlumb.Anchors.BOTTOM_RIGHT,jsPlumb.Anchors.TOP_LEFT], 
	paintStyle:{lineWidth:7,strokeStyle:'rgb(131,8,135)'},
	endpointsOnTop:false, 
	endpointStyle:{width:40, height:40},
	endpointType:new jsPlumb.Endpoints.Rectangle(), 	 
	connector:new jsPlumb.Connectors.Straight()	
});</pre>
					</div>
				</li>
				<li>Plumb window1 to window2 with the default paint settings but provide some drag options (which are passed through to jQuery's draggable call):			
					<div class="code">			
						<pre>$("#window1").plumb({target:'window2', dragOptions:{cursor:'crosshair'}});</pre>
					</div>
				</li>
				<li>Detach window2 from window1
					<div class="code">
						<pre>$("#window2").detach("window1");</pre>
					</div>
				</li>
				<li>Detach window2 from window1 and window3
					<div class="code">
						<pre>$("#window2").detach(["window1", "window3"]);</pre>
					</div>
				</li>
				<li>Detach window5 from all connections
					<div class="code">
						<pre>$("#window5").detachAll();</pre>
					</div>
				</li>
				<li>Hide all window5's connections
					<div class="code">
						<pre>jsPlumb.hide("window5");</pre>
					</div>
				</li>
				<li>Show all window5's connections
					<div class="code">
						<pre>jsPlumb.show("window5");</pre>
					</div>
				</li>
				<li>Toggle the visibility of window5's connections
					<div class="code">
						<pre>jsPlumb.toggle("window5");</pre>
					</div>
				</li>
			</ul>			
		</div>
		<div class="section">			
			<a id="options"><h3>Options</h3></a>
			<p>These are the options you can specify on a call to the plumb method:</p>
			<ul>
				<li><strong>target</strong>
					<p>This is a required argument.  It identifies the target element for the plumb.</p>
				</li>
				<li><strong>paintStyle</strong>
					<p>Optional; if not supplied jsPlumb uses the values defined in jsPlumb.DEFAULT_PAINT_STYLE (see <a href="#defaults">defaults</a>). This object allows you to specify four attributes of the connector:
						<ul>
							<li>strokeStyle	- the color used to paint the connector.  NOTE: jsPlumb does not yet support patterns, and gradient support is limited to linear gradients in Connectors only.</li>
							<li>lineWidth - the width of the connector in pixels</li>
							<li>lineCap - how the end of the line will be capped.</li>
							<li>miterLimit - the limit on how mitery the miters can miterate.</li>
							<li>gradient - you can specify a set of colors to use as a gradient for the Connector. see <a href="#gradients">Gradients</a></li>
						</ul>
					</p>
					<p>
					The arguments to the strokeStyle parameter can be anything that is a valid argument for the strokeStyle parameter of HTML Canvas element, which
					are CSS colors, patterns or gradients.
					</p>
					<p>
					This is the <a class="mplink" href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html" target="_blank">working group's page for the Canvas element</a>, where you can find information
					on painting in Canvas.
					</p>
					<p>
					Mozilla also has some good documentation <a class="mplink" href="https://developer.mozilla.org/en/Canvas_tutorial/Applying_styles_and_colors" target="_blank">here</a>
					</p>				
				</li>
				<li><strong>connector</strong>
					<p>Optional; if not supplied jsPlumb uses a Bezier connector (see <a href="#defaults">defaults</a>)</p>
					<p>Valid values for this are:
						<ul>
							<li>new jsPlumb.Connectors.Straight - a straight line directly connecting two anchors</li>
							<li>new jsPlumb.Connectors.Bezier(optional_curviness_value) - a Bezier curve connecting two anchors.</li>
						</ul>
					</p>
					<p>You can also supply your own Connector implementation; for details on how to write a Connector see
					the <a href="#connectors">Connectors</a> section below.</p>
				</li>
				<li><strong>anchors</strong>
					<p>Optional; if not supplied jsPlumb uses [jsPlumb.Anchors.BOTTOM_CENTER, jsPlumb.Anchors.TOP_CENTER]  (see <a href="#defaults">defaults</a>)</p>
					<p>If you supply this, it must be in the form of a list with two elements - the first element is
					the anchor type for the source element (the one on which you are calling the 'plumb' method), and the
					second is the anchor type for the target element.
					</p>
					<p>Valid values for this are any Anchor you have created yourself (see the <a href="#anchors">anchors</a> section below), or one
					of these default anchors provided by jsPlumb:
						<ul>
							<li>jsPlumb.Anchors.TOP_CENTER</li>
							<li>jsPlumb.Anchors.TOP_RIGHT</li>
							<li>jsPlumb.Anchors.RIGHT_MIDDLE</li>
							<li>jsPlumb.Anchors.BOTTOM_RIGHT</li>
							<li>jsPlumb.Anchors.BOTTOM_CENTER</li>
							<li>jsPlumb.Anchors.BOTTOM_LEFT</li>
							<li>jsPlumb.Anchors.LEFT_MIDDLE</li>
							<li>jsPlumb.Anchors.TOP_LEFT</li>
							<li>jsPlumb.Anchors.CENTER</li>
						</ul>												
					</p>
					<p>The locations of these are hopefully self-explanatory.  You can supply your own Anchor implementations if you need to - see the section on <a href="#anchors">Anchors</a></p>
				</li>
				<li><strong>endpoint</strong>
					<p>Optional; if not supplied jsPlumb uses jsPlumb.Endpoints.DOT, with the default size of 10  (see <a href="#defaults">defaults</a>).</p>
					<p>Valid values for this are:
						<ul>
							<li>new jsPlumb.Endpoints.Dot</li>
							<li>new jsPlumb.Endpoints.Rectangle</li>
						</ul>
					</p>
					<p>Similar to Connectors and Anchors, you can provide your own endpoint implementation; see the <a href="#endpoints">Endpoints</a> section.</p>
				</li>
				<li><strong>endpointStyle</strong>
					<p>Optional; if not supplied jsPlumb uses the values defined in jsPlumb.DEFAULT_ENDPOINT_STYLE  (see <a href="#defaults">defaults</a>).</p>
					<p>This Javascript object allows you to specify one argument for the endpoint:
						<ul>
							<li>fillStyle - the color to fill the endpoint with.</li>
						</ul>
						<br />
					</p>
				</li>
				<li><strong>endpointsOnTop</strong>
					<p>This is a boolean value that defaults to true.  When true, it forces jsPlumb to set the z-index of endpoints
						to be 1 more than that of the element to which they belong.  This is perhaps not the most awesome thing.
						Something tells me a better way to manage all of this is in CSS (see the <a href="#connectors">connectors</a>, 
						<a href="#endpoints">endpoints</a> and <a href="#anchors">anchors</a> sections for information on what CSS classes
						jsPlumb uses). 
					</p>
				</li>
				<li><strong>drawEndpoints</strong>
					<p>This is a boolean value that defaults to true.</p>
				</li>
				<li><strong>dragOptions</strong>
					<p>
						You can provide your own set of dragOptions to pass through to the call to jQuery's draggable(..) function if you need to. jsPlumb will wrap any drag
						method you provide, since it needs to be aware of drag activity, but everything else is passed through as you specify it. You can do this either on
						each call you make:
						<div class="code">
							<pre>$("#someWindow").plumb({target:"otherWindow", dragOptions:{cursor: 'crosshair'}});</pre>
						</div>
				 		or for convenience you might want to override the defaults:
						<div class="code">
							<pre>jsPlumb.DEFAULT_DRAG_OPTIONS = { .. your drag options here. };</pre>
						</div>
						Consult <a class="mplink" target="_blank" href="http://docs.jquery.com/UI/Draggable">the jQuery documentation</a> for more information on what you can pass as drag options.</p>
					</p>
				</li>
			</ul>
			
			
		</div>
				
		<div class="section">			
			<a id="defaults"><h3>Defaults</h3></a>
			The easiest way to set a look and feel for your plumbing is to override the defaults that jsPlumb uses. If you
			do not do this you are forced to provide your overridden values on every call.  Every argument to the plumb method has an
			associated default value in jsPlumb.<br/><br/>
			
			The defaults that ship with jsPlumb are:
	
			<div class="code">
<pre>DEFAULT_PAINT_STYLE : {
    lineWidth : 10,
    strokeStyle : "red"
}
			
DEFAULT_DRAG_OPTIONS : { }

DEFAULT_ENDPOINT_STYLE : { fillStyle : null; }

DEFAULT_ENDPOINT_STYLES : [ null, null ]

DEFAULT_ANCHORS : [ jsPlumb.Anchors.BOTTOM_CENTER, jsPlumb.Anchors.TOP_CENTER ]

DEFAULT_CONNECTOR : jsPlumb.Connectors.Bezier;

DEFAULT_ENDPOINT : jsPlumb.Endpoints.Dot;

DEFAULT_ENDPOINTS : [jsPlumb.Endpoints.Dot, jsPlumb.Endpoints.Dot];
</pre>
			</div>
			<p>
			Note that in DEFAULT_ENDPOINT_STYLE, the default fillStyle is 'null'.  This instructs jsPlumb to use the strokeStyle
from the attached connector to fill the endpoint.</p>
<p>Note also that you can specify either or both (or neither) of 'DEFAULT_ENDPOINT_STYLE' and 'DEFAULT_ENDPOINT_STYLES'.  This allows you to specify a different
end point for each end of a connection.  'DEFAULT_ENDPOINT' and 'DEFAULT_ENDPOINTS' use the same concept.  jsPlumb will look first in the
individual endpoint/endpoint style arrays, and then fall back to the single default version.</p>
			
			you can override these defaults by including this in a script somewhere:
			<div class="code">
<pre>
jsPlumb.DEFAULT_PAINT_STYLE = {
	lineWidth:13,
	strokeStyle: 'rgba(200,0,0,100)'
}

jsPlumb.DEFAULT_DRAG_OPTIONS = { cursor: 'crosshair' };

jsPlumb.DEFAULT_ENDPOINTS = [ new jsPlumb.Endpoints.Dot(7), new jsPlumb.Endpoints.Dot(11) ]

jsPlumb.DEFAULT_ENDPOINT_STYLES = [{ fillStyle:'#225588' }, { fillStyle:'#558822' }]; 
</pre>
			</div>
			after the jsPlumb script has been loaded of course!  Here we have specified the following default behaviour:
			<ul>
				<li>connectors are 13 pixels wide and painted with a semi-transparent red line</li>
				<li>when dragging an element the crosshair cursor is used</li>
				<li>the source endpoint is a dot of radius 7; the target endpoint is a dot of radius 11</li>
				<li>the source endpoint is blue; the target endpoint is green</li>
			</ul> 
				
		</div>
		
		<div class="section">		
			<a id="anchors"><h3>Anchors</h3></a>
			<p>An Anchor models the notion of where on an element a plumb line should connect.  jsPlumb has nine default anchor locations you 
			can use to specify where the plumb lines connect to elements: these are the four corners of an element,
			the center of the element, and the midpoint of each edge of the element.</p>
			<p>You can provide your own anchor locations if you need to.  jsPlumb supports two ways of doing this:
				<ul>
					<li>jsPlumb.makeAnchor(x, y, xOrientation, yOrientation, xOffset, yOffset) function
					<p>
					This function creates a basic Anchor of the type that jsPlumb uses internally, which is a statically located anchor whose
					position is specified by providing a fractional distance for both x and y.  For instance, the TOP_CENTER anchor in jsPlumb
					is situated at [0, 0.5].
					</p>
					A call to jsPlumb.makeAnchor should look something like this:
<div class="code">
<pre>
var myAnchor = jsPlumb.makeAnchor( 0.333, 0.5, 0, 1 );
</pre>
</div>					
					<p>
					Here we have specified an anchor that will be located at a point which is one-third of the width of the element, and half its height.  The orientation array indicates that the natural flow of connectors from this element is unspecified for the x direction, but straight down the page in the y direction.  			
					</p>
					The arguments are:
					<ul>
						<li>x - required. decimal value indicating proportional location with respect to width of the element. 0 is left. 1 is full width.  note that you can use any numbers here, even outside of the 0-1 range.  </li>
						<li>y - required. decimal value indicating proportional location with respect to height of the element. 0 is left. 1 is full height.  note that you can use any numbers here, even outside of the 0-1 range.  </li>
						<li>xOrientation - optional, defaults to 0.  Defines the x hint for the general direction in which connectors leaving the anchor should travel.  Valid values are 0, 1, or -1.</li>
						<li>yOrientation - optional, defaults to 0.  Defines the y hint for the general direction in which connectors leaving the anchor should travel.  Valid values are 0, 1, or -1.</li>
						<li>xOffset - optional, defaults to 0.  Optional absolute pixel value offset to apply once the relative positioning has been performed.</li>
						<li>yOffset - optional, defaults to 0.  Optional absolute pixel value offset to apply once the relative positioning has been performed.</li>
					</ul>
					<br/>
					</li>
					<li>Providing your own anchor function
					<p>
					For most cases, the jsPlumb.makeAnchor function will probably suffice.  But the method signature of the <em>compute</em> function
					of an anchor takes the location of <strong>both elements</strong>, meaning it is possible to write an anchor whose position takes
					into account where the current element is in relation to the one it is plumbed to.  jsPlumb does not natively do this but it
					seems like something that might be useful. 
					</p>
					<p>An anchors function consists of two parts - a function that computes the location of the anchor, given the current xy and width/height of the source 
					element and target element, plus an 'orientation' array, which gives jsPlumb hints
					about which way plumb lines should flow into and out of the anchor point.  Not every Connector implementation 
					will use this orientation array - the Straight Connector, for instance, ignores it completely, because it just
					directly connects the two anchor points.
					</p>
					<p>
			To provide your own anchor location you can either set it in amongst the defaults:
			<div class="code">
<pre>
jsPlumb.Anchors.MY_ANCHOR = {
	compute : function(xy, wh, txy, twh) { 	// do some maths and return an [x,y] location }
	orientation : [ox, oy]       	// each value can be one of -1, 0 or 1. 0 means dont care, 
								 	// 1 or -1 means go in this direction in this plane.
};
</pre>
			</div>			
			or you can create it elsewhere and reference it in your calls:
			<div class="code">
<pre>
var myAnchor =  {
	compute : function(xy, wh, txy, twh) {  	// do some maths and return an [x,y] location }
	orientation : [ox, oy]       	// each value can be one of -1, 0 or 1. 0 means dont care, 
									// 1 or -1 means go in this direction in this plane.
};

$("someWindow").plumb({target:'otherWindow', anchors:[myAnchor, myAnchor]});
</pre>
			</div>			
			The arguments to the compute function are:
			<ul>
				<li>xy - location (on screen) of the source element's top left corner</li>
				<li>wh - dimensions of the source element</li>
				<li>txy - location (on screen) of the target element's top left corner</li>
				<li>twh - dimensions of the target element</li>
			</ul>			
			</p>
			<p>The <em>compute</em> function should return an array of two elements - the [x,y] on screen where the anchor is located.</p>
			<p>
			Examples of the <em>orientation</em> array can be found in the Javascript source.  It is simply a hint to jsPlumb
			of what direction a plumb line leaving the given anchor should _initially_ head in.  So, for example, the TOP_CENTER
			anchor point defines its orientation as [0,-1], meaning "i don't care about x, but i want you to head towards the
			top of the screen as you leave this point".  Take another example - BOTTOM_RIGHT.  This is the bottom right corner
			of an element.  It declares its orientation to be [1,1], meaning go down and to the right as you leave this element. 
			</p>
							
					</li>
				</ul>
			</p>
			
					</div>
		
		<div class="section">		
			<a id="connectors"><h3>Connectors</h3></a>			
			Connectors are the lines that actually join elements of the UI.  jsPlumb has two connector implementations - a straight line and a Bezier curve.  The default connector is the Bezier curve.
			<p>jsPlumb attaches the CSS class <em>_jsPlumb_connector</em> to Connectors that it generates.</p>  	
				<h4><a id="bezierConnector">Bezier Connector</a></h4>
				<p>The Bezier Connector provides a Bezier path between the two endpoints.  You construct one like this:
				<br/><br/>
				var myConnector = new jsPlumb.Connectors.Bezier(curviness);<br/><br/>
				<strong>curviness</strong>, which is optional (and defaults to 150), defines the distance in pixels that
				the Bezier's control points are situated from the anchor points.  This does not mean that your
				connector will pass through a point at this distance from your curve.  It is a hint to how you want the
				curve to travel. Rather than discuss Bezier curves at length here, because they are a very complex topic,
				we refer you to <a href="http://en.wikipedia.org/wiki/B%C3%A9zier_curve" target="_blank">Wikipedia.</a>
				</p>
				<h4><a id="straightConnector">Straight Connector</a></h4>
				<p>The Straight Connector draws a straight line between the two endpoints.  You construct one like this:
				<br/><br/>
				var myConnector = new jsPlumb.Connectors.Straight();<br/><br/>
				</p>	
			<p>
			<h4><a id="customConnectors">Custom Connectors</a></h4>
			You can provide your own connectors if you need to. A Connector consists of two functions, which work as a pair.  First a call is made to the <em>compute</em> function:
			
			<div class="code">
<pre>
compute : function(sourcePos, targetPos, sourceAnchor, targetAnchor, lineWidth) { 
	... 
	return dimensions;	
}
</pre>
			</div>
			which is expected to return a list that the <em>paint</em> function can make sense of.  The first four entries in the
			list <strong>must be</strong> the [x,y,width,height] values for the canvas that the connector will be drawn on; jsPlumb will
			use this information to size the canvas prior to calling the Connector's <em>paint</em> function.  Therefore it
			is the Connector's responsibility to ensure that the returned dimensions describe a large enough space for
			the line that will be drawn on it.</p><p>The next four elements <strong>must be</strong> the coordinates of the two endpoints of the line
			you are going to draw.</p><p>The remainder of the items in the returned list are arbitrary, and will
			vary between Connector implementations; this list is passed in to a Connector's <em>paint</em> function, so each
			implementation will put into the list whatever it needs to paint itself.  For instance, the straight line
			connector only needs the [x,y] location of each end of the line it will paint, and that is one of the required entries, so
			it does not have to do anything extra,  whereas the Bezier connector adds the location of the two control points.  Other types of 
			Connectors will do whatever is appropriate for their particular situation. 
			</p>
			This is the method signature for the <em>paint</em> function:
			<div class="code">
				<pre>paint : function(dimensions, ctx) { .. }</pre>
			</div>
			
			here, the 'dimensions' argument to the 'paint' function is the return value of the 'compute' function.  The 'ctx' argument is the Canvas context; you 
			will do all your drawing on this.
			</p>
			To change the connector from the default, specify it in your plumb call:
			<div class="code">
				<pre>$("#someWindow").plumb({target:'otherWindow', connector:jsPlumb.Connectors.Straight});</pre>
			</div>		
		</div>
		
		<div class="section">		
			<a id="endpoints"><h3>Endpoints</h3></a>		
			<p>An Endpoint is the UI component that marks the location of an Anchor, ie. the place where a Connector joins an
			element.  jsPlumb comes with three Endpoint implementations - Dot, Rectangle and Image.
				<ul>
					<li>jsPlumb.Endpoints.Dot
						<p>This draws a dot.  Example constructor:
<div class="code">
<pre>
var myDot = new jsPlumb.Endpoints.Dot({radius:34});
</pre>
</div>						
Here we created a dot with a radius of 34 pixels.  You do not need to supply the radius though - if you omit it, jsPlumb will assign a default of 10 pixels.  Note that you can also supply the radius in the endpointStyle object - see the next paragraph.
						</p><p>
						In the <em>endpointStyle</em> option of a <em>plumb</em> call, you can set two values
						that this will pick up:
							<ul>
								<li>radius - the radius of the dot (in pixels)</li>
								<li>fillStyle - the style to use when filling the dot.  note that if this is blank, jsPlumb will
								attempt to use the strokeStyle from the associated Connector.</li>
							</ul>
							<br/>
						</p>
					</li>
					<li>jsPlumb.Endpoints.Rectangle
						<p>Draws a rectangle.  Example constructor:  
<div class="code">
<pre>
var myRect = new jsPlumb.Endpoints.Rectangle({width:34, height:10});
</pre>
</div>							
Here we created a rectangle of size 34x10.  If you omit the size when you create a Rectangle, jsPlumb will use defaults of 20x20.  Just like with the Dot endpoint, you can also provide this information in the endpointStyle.
</p><p>						
						In the <em>endpointStyle</em> you can set the following for this:
							<ul>
								<li>width - optional, defaults to 20.</li>
								<li>height - optional, defaults to 20.</li>
								<li>fillStyle - the style to use when filling the rectangle.  note that if this is blank, jsPlumb will
								attempt to use the strokeStyle from the associated Connector.</li>
							</ul>
							<br/>
						</p>
					</li>
					<li>jsPlumb.Endpoints.Image
						<p>Draws an image from a given URL.  Example constructor:
<div class="code">
<pre>
var myImage = new jsPlumb.Endpoints.Image({url:"http://myserver.com/images/endpoint.png"});
</pre>
</div>							
This creates an Image endpoint with the image at the given url.  You do not need to provide dimensions.  jsPlumb will figure that out for you.
						</p>
					</li>					
				</ul>
			</p>
			<p>To create your own Endpoint implementation, you need to implement a single method:
				<div class="code"><pre>paint : function(anchorPoint, canvas, endpointStyle, connectorPaintStyle) { ... }</pre></div>
				The arguments to this method are as follows:
				<ul>
					<li>anchorPoint - [x,y] location of the anchor point on screen</li>
					<li>canvas - the canvas to draw into</li>
					<li>endpointStyle - Javascript object containing style directives as discussed above.  The contents of this are arbitrary, so if you write a new Endpoint that needs some extra settings, you can add them no hassle.</li>
					<li>connectorPaintStyle - the style being used to paint the associated Connector.</li>
				</ul>
			</p>
			<p>
				It is your responsibility to size and locate the canvas to suit your needs. jsPlumb provides the following
				helper methods to assist you:
				<div class="code"><pre>jsPlumb.sizeCanvas(canvas, x, y, width, height);</pre></div>
				Allows you to locate the canvas on screen and to size it.
				<div class="code"><pre>jsPlumb.applyPaintStyle(toObject, fromObject);</pre></div>
				Applies all the properties in <em>fromObject</em> to <em>toObject</em>.  Look in the jsPlumb source for
				why this might be useful for you. 
			</p>
		</div>		
		
		<div class="section">
			<a id="gradients"><h3>Gradients</h3></a>
			The Canvas element supports gradients, and jsPlumb can take advantage of this when painting your Connectors
			and/or Endpoints.  <strong>Note:</strong> this does <strong>NOT WORK in IE</strong>, because we use ExplorerCanvas in IE
			and ExplorerCanvas does not support gradients.
			<p>There are two types of gradients available in Canvas - a 'linear' gradient, which consists of colored lines all
			going in one direction, and a 'radial' gradient, which consists of colored circles emanating from a single point. 
			Because of their basic shape, jsPlumb supports only <em>linear</em> gradients for
			Connectors.  But for Endpoints, jsPlumb will support both <em>linear</em> and <em>radial</em> gradients.</p>
			<p>
				<h4>Connector gradients</h4>
				To specify a linear gradient to use in a Connector, you must add a <em>gradient</em> object to your
				Connector's <em>paintStyle</em>, for instance:
<div class="code">
<pre>
$("#window2").plumb({target:'window3', paintStyle:{ gradient:{stops:[[0,'green'], [1,'red']]}, lineWidth:15}});
</pre>
</div>			
Here we have plumbed window2 to window3 with a 15 pixel wide connector that has a gradient from green to red.</p><p> Notice the <em>gradient</em> object and the
<em>stops</em> list inside it - the gradient consists of an arbitrary number of these "color stops".  Each color stop is comprised
of two values - [position, color].  Position must be a decimal value between 0 and 1 (inclusive), and indicates where the color
stop is situated as a fraction of the length of the entire gradient.  Valid values for
the colors in the <em>stops</em> list are the same as those that are valid for <em>strokeStyle</em> when describing a color.	
			</p>
			<p>As mentioned, the <em>stops</em> list can hold an arbitrary number of entries.  Here's an example of a gradient that goes from red to blue to green, and back again through blue to red:
<div class="code">
<pre>
$("#window2").plumb({target:'window3', paintStyle:{ gradient:{stops:[[0,'red'], [0.33,'blue'], [0.66,'green'], [0.33,'blue'], [1,'red']]}, lineWidth:15}});
</pre>
</div>						
<strong>Note:</strong> jsPlumb uses ExplorerCanvas for IE, which does not support gradients.  On IE, jsPlumb will simply ignore the gradient directive
so it is best to ensure you also supply a <em>strokeStyle</em> in your paintStyle object, to give jsPlumb something to fall back on.  If you do not supply
a <em>strokeStyle</em> your Connectors will be painted black.  The previous example might look like this, for instance:
<div class="code">
<pre>
$("#window2").plumb({target:'window3', paintStyle:{ strokeStyle:'red', gradient:{stops:[[0,'red'], [0.33,'blue'], [0.66,'green'], [0.33,'blue'], [1,'red']]}, lineWidth:15}});
</pre>
</div>						
Notice the <strong>strokeStyle:'red'</strong> directive at the beginning of the parameter list.
			</p>
			<h4>Endpoint gradients</h4>
			Not yet implemented. We expect to support radial gradients in the Dot endpoint, and linear gradients in the Rectangle endpoint.
			<p>
			
			</p>
		</div>		
		
		<div class="section">
			<a id="cssclasses"><h3>CSS Class Reference</h3></a>
			jsPlumb attaches classes to each of the UI components it creates:
			<table>
				<tr><th>component</th><th>css class</th></tr>
				<tr><td>connector</td><td>_jsPlumb_connector</td></tr>
				<tr><td>endpoint</td><td>_jsPlumb_endpoint</td></tr>
			</table> 
		</div>

		
		<div class="section"> 		
			<a id="enhancements"><h3>Possible Future Enhancements</h3></a>
			<ul>
				<li>Support gradients in Endpoints, and patterns in both Endpoints and Connectors.
					<p>It is possible to stroke a line in the Canvas element with both gradients and patterns.  Currently jsPlumb supports only
					gradients in Connectors.</p>
				</li>
				<li>Move the random endpoint-related keys inside the endpointStyle object.<br/><br/>					
				</li>
				<li>Smart z-index handling.  After you use jsPlumb for a little while you might see what I mean.<br/><br/>					
				</li>		
				<li>Support an endpoint deriving its color from the color of the element to which it is attached?<br/><br/></li>
				<li>Attach DOM listeners so jsPlumb is aware when elements move/change size/disappear/appear etc.</li>
			</ul>
		</div> 		
		
		<!-- Start of StatCounter Code -->
<script type="text/javascript">
var sc_project=5700644; 
var sc_invisible=1; 
var sc_partition=71; 
var sc_click_stat=1; 
var sc_security="1cb90164"; 
</script>

<script type="text/javascript"
src="http://www.statcounter.com/counter/counter.js"></script><noscript><div
class="statcounter"><a title="counter for wordpress"
href="http://www.statcounter.com/wordpress.org/"
target="_blank"><img class="statcounter"
src="http://c.statcounter.com/5700644/0/1cb90164/1/"
alt="counter for wordpress" ></a></div></noscript>
<!-- End of StatCounter Code -->
 	</body>
 </html>