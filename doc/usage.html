<html>
	<head>
		<title>jsPlumb - documentation</title>
		<link rel="stylesheet" href="/mp.css"></link>
		<link rel="stylesheet" href="../css/jsPlumbDemo.css"></link>
	</head>
	<body>
		<div class="menu"><a href="../html/demo.html" class="mplink">view demo</a>&nbsp;|&nbsp;<a href="mailto:simon.porritt@gmail.com" class="mplink">contact me</a></div>

	<div class="section">
			<h3>Index</h3>
			<ul>
				<li><a href="#summary">Summary</a></li>
				<li><a href="#changes">Changes since version 1.2.3</a></li>
				<li><a href="#requirements">Imports</a></li>
				<li><a href="#jsPlumbBasics">jsPlumb Basic Concepts</a></li>
				<li><a href="#simpleConnections">jsPlumb Basic Concepts - Simple Connections</a></li>
				<li><a href="#draggableConnections">jsPlumb Basic Concepts - Draggable Connections</a></li>
				<li><a href="#dragOptions">jsPlumb Basic Concepts - Drag Options</a></li>
				<li><a href="#dropOptions">jsPlumb Basic Concepts - Drop Options</a></li>
				<li><a href="#dragAndDropScope">jsPlumb Basic Concepts - Drag and Drop Scope</a></li>
				<li><a href="#multipleInstances">Multiple Instances of jsPlumb</a></li>							
				<li><a href="#repaint">Automatic repaint</a></li>
				<li><a href="#unload">Unloading jsPlumb</a></li>
				<li><a href="#options">jsPlumb.connect Options</a></li>
				<li><a href="#detachOptions">jsPlumb.detach Options</a></li>
				<li><a href="#defaults">Defaults</a></li>
				<li><a href="#anchors">Anchors</a></li>
				<li><a href="#dynamicAnchors">Dynamic Anchors</a></li>
				<li><a href="#connectors">Connectors</a></li>
				<li><a href="#overlays">Overlays</a></li>				
				<li><a href="#endpoints">Endpoints</a></li>
				<li><a href="#endpointOperations">Endpoint Operations</a></li>
				<li><a href="#endpointUuids">Endpoint UUIDs</a></li>
				<li><a href="#gradients">Gradients</a></li>
				<li><a href="#animation">Animation</a></li>
				<li><a href="#events">Events</a></li>
				<li><a href="#cssclasses">CSS Class Reference</a></li>				
				<li><a href="#examples">Basic Examples</a></li>				
				<li><a href="#dragAndDropExamples">Draggable Connections Examples</a></li>
				<li><a href="#connectionInfo">Retrieving Connection Information</a></li>
				<li><a href="#developingJsPlumb">Advanced - jsPlumb internals</a></li>
				<li><a href="#pluggableLibrarySupport">Pluggable Library Support</a></li>
			</ul>
			<strong>NOTE: This document refers to release 1.2.4 of jsPlumb.</strong>  
			<strong>26/11/10</strong>
		</div>

		<div class="section">
			<a id="summary"><h3>Summary</h3></a>
			jsPlumb allows you to connect elements on the screen with "plumbing", using a Canvas
			element when supported, and Google's <a class="mplink" href="http://excanvas.sourceforge.net/" target="_blank">ExplorerCanvas</a> script to support older browsers.
			<p>
			It can be used with either jQuery or MooTools (or another library of your choice if you
			feel like implementing a plugin for it).  Required versions are as follows:
			<h4>jQuery</h4>
				<ul>
					<li>jQuery 1.3.x or 1.4.x. We have tested on 1.3.2 and 1.4.2</li>
					<li>jQuery UI 1.7.x or 1.8.x (if you wish to support drag and drop). We have tested on 1.7.2 and 1.8.0.</li>
				</ul>
			<h4>MooTools</h4>
				<ul>
					<li>MooTools Core 1.2.4. It's possible other 1.2.x versions will work; we have tested only with 1.2.4.</li>
					<li>Drag.Move from MooTools More 1.2.4.4 (if you wish to support drag and drop). Again, it's possible other versions will work, but we've tested with just this one.</li>
				</ul>
			</p>
			<p>
			For Canvas support in IE you also need to include Google's <a class="mplink" href="http://excanvas.sourceforge.net/" target="_blank">ExplorerCanvas</a> script.
			</p>
			<p>jsPlumb 1.2.4 has been tested on the following browsers:
				<ul>
					<li>IE 7 on Windows Vista</li>
					<li>IE 8 on Windows Vista (we force IE7 standards compatibility mode)</li>
					<li>Firefox 3.5.8 on Windows Vista</li>
					<li>Firefox 3.6.3 on Ubuntu 10.04</li>
					<li>Chrome 5 on Ubuntu 10.04</li>
					<li>Safari 4 on Mac Tiger</li>
					<li>Safari 4 on Windows Vista</li>
					<li>Opera 10.54 on Windows Vista</li>
				</ul>
			</p>
		</div>
		
		<div class="section">
			<a id="changes">Changes since version 1.2.3</a>			
			<ul>
				<li>major performance enhancements</li>
				<li><strong>anchors are no longer static</strong> - important. This is an API change.  See the <a href="#anchors">Anchors</a> section.</li>
				<li>Image overlay type</li>
				<li>added support for multi line labels</li>
				<li>added connectorOverlays option to Endpoint</li>
				<li>added connections to getConnections method output</li>											
			</ul>
			<p>
			</p>
			<p> 
			</p>
			<p>
			These issues have been fixed:
			</p>    
			<ul>
				<li>issue 35 - detach event contained wrong source endpoint</li>
				<li>issue 42 - jsPlumb_dragged class not removed from element after drag</li>
			</ul>
		</div>

		<div class="section">
			<a id="requirements"><h3>Imports</h3></a>
			<h4>jQuery</h4>
			Example using jQuery 1.3.x or 1.4.x, jQueryUI 1.7.x or 1.8.x, and ExplorerCanvas:
			<div class="code">
			<pre>&lt;script type="text/javascript" src="http://explorercanvas.googlecode.com/svn/trunk/excanvas.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.0/jquery-ui.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="PATH_TO/jquery.jsPlumb-1.2.4-all-min.js "&gt;&lt;/script&gt;</pre>
			</div>
			
			<h4>MooTools</h4>
			Example MooTools 1.2.4, Drag.Move from MooTools More 1.2.4.4, and ExplorerCanvas:
			<div class="code">
			<pre>&lt;script type="text/javascript" src="http://explorercanvas.googlecode.com/svn/trunk/excanvas.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/mootools/1.2.4/mootools-yui-compressed.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="PATH_TO_MOO_TOOLS_MORE_1_2_4_4"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="PATH_TO/mootools.jsPlumb-1.2.4-all-min.js "&gt;&lt;/script&gt;</pre>
			</div>
		</div>
		
		<div class="section">
			<a id="jsPlumbBasics"><h3>jsPlumb Basic Concepts</h3></a>
			There are five core concepts in jsPlumb:
			<ul>
				<li>Connector - a line connecting two elements in the page</li>
				<li>Endpoint - the visual representation of one end of a Connection</li>
				<li>Anchor - a location, relative to an element's origin, at which an Endpoint can exist</li>
				<li>Overlay - a UI component that is used to decorate a Connector, such as a label, arrow, etc.</li>
				<li>Connection - an instance of Anchors, Endpoints and a Connector with zero or more Overlays working together to join two elements.</li>
			</ul>
			Connecting two elements - making a Connection - involves three steps:
			<ol>
				<li>Create an Anchor for each of the two elements you wish to connect.</li>
				<li>Create an Endpoint for each of these Anchors, and assign them.</li>
				<li>Join the two Endpoints with a Connector.</li>
			</ol>			
			Depending on whether or not you wish to be able drag new Connections, step 2 can be
			omitted.
			<a id="simpleConnections"><h4>Simple Connections</h4></a>
			This section discusses Connections in which you do not need to support drag and drop.  <br/><br/>The most simple connection you can make looks like this:
			<div class="code">
<pre>
jsPlumb.connect({source:'element1', target:'element2'});
</pre>			
			</div>
			Note: if you're using jQuery, the 'connect' method is aliased with this shorthand (this applies to 
			all the examples using the 'connect' method, but I won't mention it again):
			<div class="code">
<pre>
$("#element1").plumb({target:'element2'});
</pre>			
			</div>
		In this example we have created a Connection from 'element1' to 'element2'.  What happened to the
		three steps I mentioned above? Well, jsPlumb provides defaults for <em>everything</em>. So in this
		example, behind the scenes jsPlumb used default values for all of these things:
		<ul>
			<li>the Anchors that define where the connection's Endpoints appear on each element</li>
			<li>the type and appearance of each Endpoint in the Connection</li>
			<li>the type and appearance of the Connection's Connector</li>
		</ul>
		Default values are discussed in detail in the <a href="#defaults">Defaults</a> section below.<br/><br/>
		The <a href="#examples">Basic Examples</a> section below contains many more examples of how to create simple Connections.
		
		<a id="draggableConnections"><h4>Draggable Connections</h4></a>
		To support draggable Connections, you are required to first create Endpoints, as it is Endpoints
		that the user drags to create new Connections.  Endpoints are created by making an <strong>addEndpoint</strong> call,
		passing in the target element's id and an options object. There are quite a few things that can be set on the options object; all
		of these parameters are optional.
		<ul>
			<li>endpoint - the type of Endpoint, eg. Dot, Rectangle, Image.</li>
			<li>anchor - the Endpoint's Anchor, ie. where it will be located.</li>
			<li>style - the Endpoint's appearance</li>			
			<li>isSource - a boolean indicating whether or not the Endpoint can be a source for new Connections. Default is false.</li>
			<li>isTarget - a boolean indicating whether or not the Endpoint can be a target for new Connections. Default is false.</li>
			<li>connector - the type of Connector to use when dragging a new connection from this Endpoint. Optional.</li>
			<li>connectorStyle - the Connector's appearance (see above).</li>
			<li>dragOptions - options to pass to the supporting library's drag engine.</li>
			<li>dropOptions - options to pass to the supporting library's drop engine.</li>			
		</ul>  
		
		Here's a simple example of how to create an Endpoint:
		<div class="code">
<pre>
var endpointOptions = { isSource:true, isTarget:true };
var endpoint = jsPlumb.addEndpoint('elementId', endpointOptions);
</pre>		
</div>  	
This Endpoint will act as a source and target for new Connections, and will use the jsPlumb defaults for its own appearance and that of any Connections that are drawn from it.							
		<h4>Tip: use jsPlumb.extend </h4>
		One thing that happens quite often is that you have an Endpoint whose appearance and behaviour is largely the
		same between usages on different elements, with just a few differences.  In these cases it can be quite handy
		to use jsPlumb's 'extend' function.  For example, here's a basic Endpoint:
		<div class="code">
<pre>
var exampleGreyEndpointOptions = {
	endpoint:new jsPlumb.Endpoints.Rectangle(),
	style:{ width:25, height:21, fillStyle:'#666' },
	isSource:true,
	connectorStyle : { strokeStyle:"#666" },
	isTarget:true
};
</pre>		
</div>  		
		Notice there is no 'anchor' set.  Here we apply it to two elements, at a different location in each:
		<div class="code">
<pre>
jsPlumb.addEndpoint('element1', jsPlumb.extend({anchor:"BottomCenter", exampleGreyEndpointOptions)); 

jsPlumb.addEndpoint('element2', jsPlumb.extend({anchor:"TopCenter", exampleGreyEndpointOptions));
</pre>		
</div>
Note: jsPlumb's 'extend' function is just a wrapper around the supporting library's implementation; you don't need to use
it if you know the supporting library's corresponding method.

<a id="dragOptions"><h4>Drag Options</h4></a>
	These are options that will be passed through to the supporting library's drag API.  jsPlumb passes everything you supply here through, inserting
	wrapping functions if necessary for the various lifecycle events that jsPlumb needs to know about.  So if, for example, you pass a function to be
	called when dragging starts, jsPlumb will wrap that function with a function that does what jsPlumb needs to do, then call yours.
	<p>
	At the time of writing, jsPlumb supports jQuery and MooTools, and each of those libraries uses different terminology.  In addition, jQuery's API is
	more fully featured, providing easy support for setting the zIndex and opacity of elements being dragged, as well as the 'scope' for a drag/drop (allowing
	you to specify more than one type of drag/drop pair), and hover classes for when a draggable is on the move or
	over a droppable. If you're using jQuery you can of course just supply these values on the dragOptions; to make it easier, jsPlumb's MooTools adapter recognizes 
	these options and adds appropriate callbacks for you.  
	</p> 
	<p>
	Given that the options here are library-specific, and both jQuery and MooTools are well-documented, we're going to discuss just the three drag options
	that behave the same way in both (see below for hoverClass):
		<ul>
		<li>opacity - the opacity of an element that is being dragged.  Should be a fraction between 0 and 1 inclusive.</li>
		<li>zIndex - the zIndex of an element that is being dragged.</li>
		<li>scope - the scope of the draggable.  can only be dropped on a droppable with the same scope.  this is discussed below.</li>
		</ul> 
	</p>
	
	<p>For more information about drag options, take a look at the <a href="http://docs.jquery.com/UI/Draggable" target="_blank">jQuery</a> or <a href="http://mootools.net/docs/more/Drag/Drag.Move" target="_blank">MooTools</a> docs.	
	</p>
	<p><strong>NOTE: there is an issue in Chrome that affects the 'cursor' argument to drag options in jQuery. See these links:</strong>
<a href="http://forum.jquery.com/topic/draggable-cursor-option-does-not-work" target="_blank">http://forum.jquery.com/topic/draggable-cursor-option-does-not-work</a>
<a href="http://forum.jquery.com/topic/chrome-text-select-cursor-on-drag" target="_blank">http://forum.jquery.com/topic/chrome-text-select-cursor-on-drag</a>
	
<div class="code">
<pre>document.onselectstart = function () { return false; };</pre>
</div>
				
	</p>
	
	<a id="dropOptions"><h4>Drop Options</h4></a>
	Drop options are treated by jsPlumb in the same way as drag options - they are passed through to the underlying library.  MooTools does not have drop options like jQuery does; droppable functionality in MooTools 
	is actually implemented by the Drag.Move class - the one used to initialise a draggable.  But when you setup an Endpoint in jsPlumb you should ignore
	that fact, and treat droppables like you would in jQuery.  jsPlumb wires everything up for you under the hood.
	<p>There are two jQuery droppable options that jsPlumb treats as shortcuts in MooTools:
		<ul>
			<li>hoverClass - the CSS class to attach to a droppable when a draggable is hovering over it.</li>
			<li>scope - the scope of the draggable.  can only be dropped on a droppable with the same scope.  this is discussed below.</li>
		</ul>
	</p>   
	<p>For more information about drop options when using jQuery, see <a href="http://docs.jquery.com/UI/Droppable" target="_blank">here</a>.</p>
		
	<a id="dragAndDropScope"><h4>Scope</h4></a>
		jsPlumb borrowed the concept of 'scope' from jQuery's drag/drop implementation: the notion of
		which draggables can be dropped on which droppables.  In jsPlumb you can provide a 'scope' entry when 
		creating an Endpoint.  Here's the example grey Endpoint example with 'scope' added:
		
<div class="code">
<pre>
var exampleGreyEndpointOptions = {
	endpoint:new jsPlumb.Endpoints.Rectangle(),
	style:{ width:25, height:21, fillStyle:'#666' },
	isSource:true,
	connectionStyle : { strokeStyle:"#666" },
	isTarget:true,
	scope:'exampleGreyConnection'
};</pre>		
</div>  		
  										
	If you do not provide a 'scope' entry, jsPlumb uses a default scope.  Its value is accessible through this method:
	<div class="code">
<pre>
jsPlumb.getDefaultScope();
</pre>	
	</div>				
	If you want to change it for some reason you can do so with this method:
	<div class="code">
<pre>
jsPlumb.setDefaultScope("mySpecialDefaultScope");
</pre>	
	</div>			
	You can also, should you want to, provide the scope value separately on the drag/drop options, like this:
	<div class="code">
<pre>
var exampleGreyEndpointOptions = {
	endpoint:new jsPlumb.Endpoints.Rectangle(),
	style:{ width:25, height:21, fillStyle:'#666' },
	isSource:true,
	connectionStyle : { strokeStyle:"#666" },
	isTarget:true,
	dragOptions:{scope:'dragScope'},
	dropOptions:{scope:'dropScope'}
};</pre>		
</div>  
			
	</div>

		<div class="section">
			<a id="multipleInstances"><h3>Multiple jsPlumb instances</h3></a>
			jsPlumb is registered on the browser's Window by default, providing one static instance
			for the whole page to use.  Should you need to, though, you can instantiate independent
			instances of jsPlumb, using the <strong>getInstance</strong> method, for example:
<div class="code">
<pre>
var firstInstance = jsPlumb.getInstance();
</pre>
</div>
The variable 'firstInstance' can now be treated exactly as you would treat the 'jsPlumb' variable - you can set
defaults, call the connect method, whatever:
<div class="code">
<pre>
firstInstance.Defaults.Connector = new jsPlumb.Connectors.Bezier(150);
firstInstance.Defaults.Container = "container1";
firstInstance.Defaults.Anchors = ["TopCenter", "BottomCenter"];

firstInstance.connect({source:'element1', target:'element2', scope:'someScope'});
</pre>
</div>

<strong>getInstance</strong> optionally takes an object that provides the defaults:
<div class="code">
<pre>
var secondInstance = jsPlumb.getInstance({
	PaintStyle:{lineWidth:3, strokeStyle:color3},
	Connector:new jsPlumb.Connectors.Bezier(30),
	Endpoint:new jsPlumb.Endpoints.Dot({radius:5}),
	EndpointStyle : { fillStyle: color3  },
	Anchor : [ 0.5, 0.5, 1, 1 ],
	Container:"container2"
});

secondInstance.connect({source:'element4', target:'element3', scope:'someScope'});
</pre>
</div>
Notice the <strong>container</strong> directives that are set on the defaults.  This tells jsPlumb
to draw everything inside the container with the given id, giving you cleaner separation between
instances.  While not actually required in order to make multiple instances work together, you might
find it easier.  Using this concept you can, for example, drag an entire drawing area around as one.  
		</div>

		<div class="section">
			<a id="repaint"><h3>Automatic Repaint</h3></a>
			jsPlumb attaches a listener to the browser window and automatically repaints every connection
			when a window resize event occurs.  You can disable this functionality, if you want to, with
			the following call:
<div class="code">
<pre>jsPlumb.setAutomaticRepaint(false);</pre>
</div>
You can also provide your own function for jsPlumb to execute instead of its default behaviour:
<div class="code">
<pre>var repaint = function() {
	// do some things, perhaps, and then...
	jsPlumb.repaintEverything();
};

jsPlumb.setRepaintFunction(repaint);</pre>
</div>
Notice the call to <strong>repaintEverything()</strong> here - a useful method.
<p>Another example:</p>
<div class="code">
<pre>var repaint = function() {
	// completely start over
	jsPlumb.detachEverything();
	// paint all your connections
};

jsPlumb.setRepaintFunction(repaint);</pre>
</div>
		</div>
		
				<div class="section">
			<a id="unload"><h3>Unloading jsPlumb</h3></a>
			jsPlumb offers a method you can call when your page is unloading.  You should do this to insure
			against memory leaks.  You configure it like this:
				<div class="code">
<pre>
&lt;body onunload="jsPlumb.unload();"&gt;

...

&lt;/body&gt;
</pre>
				</div>
		</div>

		<div class="section">
			<a id="options"><h3>jsPlumb.connect Options</h3></a>
			<p>These are the options you can specify on a call to the connect/plumb method:</p>
			<ul>
				<li><strong>source</strong>
					<p>This is a required argument only when using 'connect' (when using 'plumb' the source element is the one on which the plumb method was called), or if you have not supplied a value for sourceEndpoint.  It identifies the source element for the plumb.  It may be a string representing the element's id, or a selector for the element.</p>
				</li>
				<li><strong>target</strong>
					<p>This is a required argument, unless you have supplied a value for targetEndpoint. It identifies the target element for the plumb.  It may be a string representing the element's id, or a selector for the element.</p>
				</li>
				<li><strong>paintStyle</strong>
					<p>Optional; if not supplied jsPlumb uses the values defined in jsPlumb.Defaults.PaintStyle (see <a href="#defaults">Defaults</a>). This object allows you to specify five attributes of the connector (note that all of these except 'gradient'
					are just passed through to the Canvas element's paint context):
						<ul>
							<li>strokeStyle	- the color used to paint the connector.  NOTE: jsPlumb does not yet support patterns.</li>
							<li>lineWidth - the width of the connector in pixels</li>
							<li>lineCap - how the end of the line will be capped.</li>
							<li>miterLimit - the limit on how mitery the miters can miterate.</li>
							<li>gradient - you can specify a set of colors to use as a gradient for the Connector. see <a href="#gradients">Gradients</a></li>
						</ul>
					</p>
					<p>
					The arguments to the strokeStyle parameter can be anything that is a valid argument for the strokeStyle parameter of HTML Canvas element, which
					are CSS colors, patterns or gradients.
					</p>
					<p>
					This is the <a class="mplink" href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html" target="_blank">working group's page for the Canvas element</a>, where you can find information
					on painting in Canvas.
					</p>
					<p>
					Mozilla also has some good documentation <a class="mplink" href="https://developer.mozilla.org/en/Canvas_tutorial/Applying_styles_and_colors" target="_blank">here</a>.
					</p>
				</li>
				<li><strong>backgroundPaintStyle</strong>
					<p>Optional; if not supplied jsPlumb uses the values defined in jsPlumb.Defaults.BackgroundPaintStyle (see <a href="#defaults">Defaults</a>), which is, 
					by default, blank. 
					</p>
					<p>This object allows you to specify a background for the connector, allowing you to do things such as shadows etc.  It takes exactly the same arguments as paintStyle discussed above.</p>
				</li>
				<li><strong>connector</strong>
					<p>Defines the appearance of the connector.  Optional; if not supplied jsPlumb uses a Bezier connector (see <a href="#defaults">Defaults</a>)</p>
					<p>Valid values for this are:
						<ul>
							<li>new jsPlumb.Connectors.Straight (optional_params) - a straight line directly connecting two anchors</li>
							<li>new jsPlumb.Connectors.Bezier (optional_curviness_value) - a Bezier curve connecting two anchors.</li>
						</ul>
					</p>
					<p>You can also supply your own Connector implementation; for details on how to write a Connector see
					the <a href="#connectors">Connectors</a> section below.</p>
				</li>
				<li><strong>anchors</strong>
					<p>Defines the location on each element to attach the Connection to.  Optional; if not supplied jsPlumb uses <strong>[ jsPlumb.Anchors.BottomCenter, jsPlumb.Anchors.TopCenter ]</strong>  (see <a href="#defaults">defaults</a>)</p>
					<p>If you supply this, it must be in the form of a list with two elements - the first element is
					the anchor type for the source element (the one on which you are calling the 'plumb' method), and the
					second is the anchor type for the target element.
					</p>
					<p>Valid values for this are any Anchor you have created yourself (see the <a href="#anchors">anchors</a> section below), or one
					of these default anchors provided by jsPlumb. Strings are shown here; they are shorthand for entries in jsPlumb.Anchors, which you can also
					use if you want (see below the list for an example of this).
						<ul>
							<li>"TopCenter"</li>
							<li>"TopRight"</li>
							<li>"RightMiddle"</li>
							<li>"BottomRight"</li>
							<li>"BottomCenter"</li>
							<li>"BottomLeft"</li>
							<li>"LeftMiddle"</li>
							<li>"TopLeft"</li>
							<li>"Center"</li>
							<li>"AutoDefault"</li>
						</ul>
					</p>
					<p>The locations of these are hopefully self-explanatory.  You can supply your own Anchor implementations, or use jsPlumb's 'makeAnchor' function to create an Anchor in a custom location, if you need to - see the section on <a href="#anchors">Anchors</a>.</p>
					<p>As mentioned above, the values given are strings, which are shorthand.  So this:
<div class="code">
<pre>anchor:"TopLeft"</pre>
</div>
is the same as this:
<div class="code">
<pre>anchor:new jsPlumb.Anchors.TopLeft()</pre>
</div>			
If you register your own type of Anchor on jsPlumb.Anchors, you can use this shorthand for it too:
<div class="code">
<pre>jsPlumb.Anchors.MyAnchor = ....;
...
anchor:"myAnchor"
...
</pre>
</div>		
					</p>
					<p>The "AutoDefault" Anchor is a Dynamic Anchor that uses four default positions - TopCenter, RightMiddle, BottomCenter and LeftMiddle.</p>
				</li>
				<li><strong>endpoint</strong>
					<p>Defines the appearance of both Endpoints in the Connection. Optional; if not supplied jsPlumb uses <strong>jsPlumb.Endpoints.Dot</strong>, with the default size of 10  (see <a href="#defaults">Defaults</a>).</p>
					<p>Valid values for this are:
						<ul>
							<li>new jsPlumb.Endpoints.Dot ( optional_params )</li>
							<li>new jsPlumb.Endpoints.Rectangle ( optional_params ) </li>
							<li>new jsPlumb.Endpoints.Image (url) </li>
							<li>new jsPlumb.Endpoints.Triangle ({width:optional, height:optional}) </li>
						</ul>
					</p>
					<p>Similar to Connectors and Anchors, you can provide your own Endpoint implementation; see the <a href="#endpoints">Endpoints</a> section.</p>
				</li>
				<li><strong>endpoints</strong>
					<p>Defines the appearance of each Endpoint separately.  Optional; this is similar to <strong>endpoint</strong> but should be used when you want to specify a different Endpoint for each end of the Connector.</p>
					<p>This should be supplied as a list, for example:
<div class="code">
<pre>endpoints:[  ..endpoint1.. ,  ..endpoint2..  ]</pre>
</div>
					</p>
				</li>
				<li><strong>endpointStyle</strong>
					<p>Defines the styles to apply to both Endpoints. Optional; if not supplied jsPlumb uses the values defined in <strong>jsPlumb.Defaults.EndpointStyle</strong>  (see <a href="#defaults">defaults</a>).</p>
					<p>This Javascript object allows you to specify the following arguments for the Endpoint:
						<ul>
							<li>fillStyle - the color to fill the endpoint with.</li>
							<li>gradient - you can specify a set of colors to use as a gradient for the Endpoint. see <a href="#gradients">Gradients</a></li>
						</ul>
						<br />
					</p>
				</li>
				<li><strong>endpointStyles</strong>
					<p>Defines the styles to apply to each Endpoint.  Optional; this is similar to <strong>endpointStyle</strong> but should be used when you want to specify a different style for each of the two Endpoints.</p>
					<p>This should be supplied as a list, for example:
<div class="code">
<pre>endpointStyles:[ { ..style1.. }, { ..style2.. } ]</pre>
</div>
					</p>
				</li>
				<li><strong>drawEndpoints</strong>
					<p>This is a boolean value that defaults to true.</p>
				</li>
				<li><strong>dragOptions</strong>
					<p>
						You can provide your own set of dragOptions to pass through to the underlying library's drag API  if you need to. jsPlumb will wrap any event
						methods you provide, since it needs to be aware of drag activity, but everything else is passed through as you specify it. You can do this either on
						each call you make:
						<div class="code">
							<pre>jsPlumb.connect({source:'someWindow', target:"otherWindow", dragOptions:{cursor: 'crosshair'}});</pre>
						</div>
				 		or for convenience you might want to override the defaults:
						<div class="code">
							<pre>jsPlumb.Defaults.DragOptions = { .. your drag options here. };</pre>
						</div>
						See the <a href="#dragOptions">Endpoints discussion</a> for more information about this.  dragOptions on an Endpoint are identical to dragOptions passed in to the 'connect' method.
					</p>
				</li>
				<li><strong>sourceEndpoint</strong>
					<p>
						This is a configured Endpoint that has already been added to some element 
						using jsPlumb.addEndpoint(...).  Note that this is distinct from the both the
						<strong>endpoint</strong> and <strong>endpoints</strong> arguments you can
						pass to jsPlumb.connect: in this case we have an Endpoint object that is
						already attached to some element at some Anchor; the other endpoint arguments
						are for passing in what _type_ of endpoint you want (as in, a Dot, or a Rectangle,
						or whatever).  It's quite possible that this part of the API should be cleaned
						up to prevent confusion.											
					</p>
				</li>
				<li><strong>targetEndpoint</strong></li>
					<p>
						This is a configured Endpoint that has already been added to some element 
						using jsPlumb.addEndpoint(...).  The same caveat applies here as applies to
						the sourceEndpoint argument discussed above.									
					</p>
				</li>
				<li>
					<strong>uuids</strong>
					<p>
						Identifies the UUIDs of the source and target Endpoints for this connection.
						These Endpoints may already exist, having been added with a call to 
						jsPlumb.addEndpoint(..), in which case you do not need to provide information
						about the source or target elements for the connection, as the Endpoints know.
						However it is also possible to supply this array when you wish to make a 
						connection and have jsPlumb create the Endpoints for you:
<div class="code">
	<pre>
jsPlumb.connect({uuids:["uuid1", "uuid2"], source:"someElement", target:"someOtherElement"});	
	</pre>
</div>						
This call would result in jsPlumb creating two Endpoints and registering them with the given UUIDs, and
then creating a Connection between them.  Of course when you use this syntax you can supply all of the
other things you might wish to tell jsPlumb, like what sort of Endpoints you want, how to draw the
Connection, etc.
					</p>					
				</li>
				<li>
					<strong>label</strong>
					<p>
					Optional label for the connection.  This is a shortcut way to add a label as an Overlay, and will place the label in the middle
					of the connection.  If you want finer-grained control you should use the 'overlays' parameter (see below, and in the Overlays section)
					</p>
					<p>
					label may be either a String:: 
					
<div class="code">
	<pre>
jsPlumb.connect({label:"Static label", source:"someElement", target:"someOtherElement"});	
	</pre>				
</div>
...or a Function that returns a String:
<div class="code">
	<pre>
jsPlumb.connect({
	label:function(connection) { 
		return (new Date()).getTime();
	}, 
	source:"someElement", 
	target:"someOtherElement"
});	
	</pre>				
</div>
The Connection is passed in as an argument to your label generation function.  Be aware that if you use a function for the label text then jsPlumb will be unable to cache the text, 
so it will be have to be recomputed every time jsPlumb receives notification of a drag event.  This could lead to UI responsiveness issues in a complex setup.
	</p>
				</li>
				<li>
					<strong>labelStyle</strong>
					<p>
					Optional instructions for how to paint the label, if you supplied one.  Possible values for this are:
					<ul>
						<li>font - a font specification that HTML Canvas can understand</li>
						<li>fillStyle - a fillStyle specification that HTML Canvas can understand; paints the background of the label.</li>
						<li>color - color for the label text, in a format that HTML Canvas can understand.</li>
					</ul>									
					</p>
					A good reference for HTML Canvas can be found on <a href="https://developer.mozilla.org/en/Drawing_text_using_a_canvas">Mozilla's Developer documentation</a>
					<p>If you do not supply a labelStyle element, jsPlumb will use the values defined in jsPlumb.Defaults.LabelStyle. (see <a href="#defaults">Defaults</a>)</p>
					Example:
					<div class="code">
<pre>
jsPlumb.connect({
		label:"Static label",
		labelStyle: {
			fillStyle:"rgba(100,100,100,80)",
			color:"white",
			font:"12px sans-serif"
		}, 
		source:"someElement", 
		target:"someOtherElement"
});	
</pre>					
					</div>
					
				</li>
				<li>
					<strong>overlays</strong>
					<p>
					This optional parameter is a list of objects that implement the Overlay interface, which is discussed in more detail in the
					<a href="#overlays">Overlays</a> section below.  Here's a brief example, though, that shows the same example we just discussed
					for labels - but in this case there is also an arrow being painted:</a>
					</p>
<div class="code">
<pre>
jsPlumb.connect({
	source:"someElement",
	target:"someOtherElement",
	overlays: [
		new jsPlumb.Overlays.Label({
			fillStyle:"rgba(100,100,100,80)",
			color:"white",
			font:"12px sans-serif",
			label:"Static label",
			borderStyle:"black",
			borderWidth:2
		}),
		new jsPlumb.Overlays.Arrow({location:0.2})
	]
});
</pre>
</div>					
The order of painting of Overlays is the order in which they are found in this list.  So in this case, if the Arrow was at the same location as the Label, 
it would be painted on top.  But here we have said that the Arrow should be at '0.2' of the length of the connection, and the Label will be at 0.5,
which is the default.
				</li>
			</ul>
		</div>
		
		<div class="section">
			<a id="detachOptions"><h3>jsPlumb.detach Options</h3></a>
			<p>Both the jsPlumb object and also individual elements have a method called 'detach'. The jsPlumb.detach method is more
			versatile and allows you to specify elements, element ids, endpoint uuids or Endpoint objects, whereas the detach method on
			individual elements can only take the id of some element, or that element's selector.  This documentation refers to the
			jsPlumb.detach method.  It has several similarities with the connect method discussed above.
			 </p>
			 <p>These are the options you can specify on a call to jsPlumb.detach. You don't need to supply them all: jsPlumb needs 
			 either [source,target] or [sourceEndpoint, targetEndpoint] or uuids. </p>
			<ul>
				<li><strong>source</strong>
					<p>Identifies the source element to find and detach connections from.  It may be a string representing the element's id, or a selector for the element.</p>
				</li>
				<li><strong>target</strong>
					<p>Identifies the target element to find and detach connections from.  It may be a string representing the element's id, or a selector for the element.</p>
				</li>
				<li><strong>sourceEndpoint</strong>
					<p>Identifies the source Endpoint to find and detach connections from.  </p>
				</li>
				<li><strong>targetEndpoint</strong>
					<p>Identifies the target Endpoint to find and detach connections from.  </p>
				</li>
				<li><strong>uuids</strong>
					<p>An array of two Endpoint UUIDs, identifying the source and target Endpoints.</p>
				</li>				
			</ul>
		</div>

		<div class="section">
			<a id="defaults"><h3>Defaults</h3></a>
			The easiest way to set a look and feel for your plumbing is to override the defaults that jsPlumb uses. If you
			do not do this you are forced to provide your overridden values on every call.  Every argument to the connect/plumb method has an
			associated default value in jsPlumb.<br/><br/>

			The defaults that ship with jsPlumb are stored in <em>jsPlumb.Defaults</em>, which is a Javascript object.  Valid entries, and their initial values, are:

			<div class="code">
<pre>
Anchor : null,
Anchors : [ null, null ],
BackgroundPaintStyle : null,
Connector : null,
Container : null,
DragOptions : {},
DropOptions : {},
Endpoint : null,
Endpoints : [ null, null ],
EndpointStyle : {
	fillStyle : null
},
EndpointStyles : [ null, null ],
LabelStyle : {
	fillStyle : "rgba(0,0,0,0)",
	color : "black"
},
LogEnabled : true,
MaxConnections : null,
PaintStyle : {
	lineWidth : 10,
	strokeStyle : 'red'
},
Scope : "_jsPlumb_DefaultScope"
</pre>
			</div>
			<p>
			Note that in EndpointStyle, the default fillStyle is 'null'.  This instructs jsPlumb to use the strokeStyle
from the attached connector to fill the endpoint.</p>
<p>Note also that you can specify either or both (or neither) of 'EndpointStyle' and 'EndpointStyles'.  This allows you to specify a different
end point for each end of a connection.  'Endpoint' and 'Endpoints' use the same concept.  jsPlumb will look first in the
individual endpoint/endpoint style arrays, and then fall back to the single default version.</p>

			you can override these defaults by including this in a script somewhere:
			<div class="code">
<pre>
jsPlumb.Defaults.PaintStyle = {
	lineWidth:13,
	strokeStyle: 'rgba(200,0,0,100)'
}

jsPlumb.Defaults.DragOptions = { cursor: 'crosshair' };

jsPlumb.Default.Endpoints = [ new jsPlumb.Endpoints.Dot(7), new jsPlumb.Endpoints.Dot(11) ]

jsPlumb.Defaults.EndpointStyles = [{ fillStyle:'#225588' }, { fillStyle:'#558822' }];
</pre>
			</div>
			after the jsPlumb script has been loaded of course!  Here we have specified the following default behaviour:
			<ul>
				<li>connectors are 13 pixels wide and painted with a semi-transparent red line</li>
				<li>when dragging an element the crosshair cursor is used</li>
				<li>the source endpoint is a dot of radius 7; the target endpoint is a dot of radius 11</li>
				<li>the source endpoint is blue; the target endpoint is green</li>
			</ul>

		</div>

		<div class="section">
			<a id="anchors"><h3>Anchors</h3></a>			
			<p>An Anchor models the notion of where on an element a plumb line should connect.  jsPlumb has nine default anchor locations you
			can use to specify where the plumb lines connect to elements: these are the four corners of an element,
			the center of the element, and the midpoint of each edge of the element.</p>
			
			<p>You can provide your own anchor locations if you need to.  jsPlumb supports two ways of doing this:
				<ul>
					<li>jsPlumb.makeAnchor(x, y, xOrientation, yOrientation, xOffset, yOffset) function
					<p>
					This function creates a basic Anchor of the type that jsPlumb uses internally, which is a statically located anchor whose
					position is specified by providing a fractional distance for both x and y.  For instance, the TopCenter anchor in jsPlumb
					is situated at [0, 0.5].
					</p>
					A call to jsPlumb.makeAnchor should look something like this:
<div class="code">
<pre>
var myAnchor = jsPlumb.makeAnchor( 0.333, 0.5, 0, 1 );
</pre>
</div>
					<p>
					Here we have specified an anchor that will be located at a point which is one-third of the width of the element, and half its height.  The orientation array indicates that the natural flow of connectors from this element is unspecified for the x direction, but straight down the page in the y direction.
					</p>
					The arguments are:
					<ul>
						<li>x - required. decimal value indicating proportional location with respect to width of the element. 0 is left. 1 is full width.  note that you can use any numbers here, even outside of the 0-1 range.  </li>
						<li>y - required. decimal value indicating proportional location with respect to height of the element. 0 is left. 1 is full height.  note that you can use any numbers here, even outside of the 0-1 range.  </li>
						<li>xOrientation - optional, defaults to 0.  Defines the x hint for the general direction in which connectors leaving the anchor should travel.  Valid values are 0, 1, or -1.</li>
						<li>yOrientation - optional, defaults to 0.  Defines the y hint for the general direction in which connectors leaving the anchor should travel.  Valid values are 0, 1, or -1.</li>
						<li>xOffset - optional, defaults to 0.  Optional absolute pixel value offset to apply once the relative positioning has been performed.</li>
						<li>yOffset - optional, defaults to 0.  Optional absolute pixel value offset to apply once the relative positioning has been performed.</li>
					</ul>
					<br/>
					</li>
					<li>Providing your own anchor function
					<p>
					For most cases, the jsPlumb.makeAnchor function will probably suffice.  But the method signature of the <em>compute</em> function
					of an anchor takes the location of <strong>both elements</strong>, meaning it is possible to write an anchor whose position takes
					into account where the current element is in relation to the one it is plumbed to.  jsPlumb uses this with Dynamic Anchors.
					</p>
					<p>An anchors function consists of two parts - a function that computes the location of the anchor, given the current xy and width/height of the source
					element and target element, plus an 'orientation' array, which gives jsPlumb hints
					about which way plumb lines should flow into and out of the anchor point.  Not every Connector implementation
					will use this orientation array - the Straight Connector, for instance, ignores it completely, because it just
					directly connects the two anchor points.
					</p>
					<p>
			To provide your own anchor location you can either set it in amongst the defaults:
			<div class="code">
<pre>
jsPlumb.Anchors.MyAnchor = {
	compute : function(xy, wh, txy, twh) { 	// do some maths and return an [x,y] location }
	orientation : [ox, oy]       	// each value can be one of -1, 0 or 1. 0 means dont care,
								 	// 1 or -1 means go in this direction in this plane.
};
</pre>
			</div>
			or you can create it elsewhere and reference it in your calls:
			<div class="code">
<pre>
var myAnchor =  {
	compute : function(xy, wh, txy, twh) {  	// do some maths and return an [x,y] location }
	orientation : [ox, oy]       	// each value can be one of -1, 0 or 1. 0 means dont care,
									// 1 or -1 means go in this direction in this plane.
};

jsPlumb.connect({source:"someWindow", target:"otherWindow", anchors:[myAnchor, myAnchor]});
</pre>
			</div>
			The arguments to the compute function are:
			<ul>
				<li>xy - location (on screen) of the source element's top left corner</li>
				<li>wh - dimensions of the source element</li>
				<li>txy - location (on screen) of the target element's top left corner</li>
				<li>twh - dimensions of the target element</li>
			</ul>
			</p>
			<p>The <em>compute</em> function should return an array of two elements - the [x,y] on screen where the anchor is located.</p>
			<p>
			Examples of the <em>orientation</em> array can be found in the Javascript source.  It is simply a hint to jsPlumb
			of what direction a plumb line leaving the given anchor should _initially_ head in.  So, for example, the TopCenter
			anchor point defines its orientation as [0,-1], meaning "i don't care about x, but i want you to head towards the
			top of the screen as you leave this point".  Take another example - BottomRight.  This is the bottom right corner
			of an element.  It declares its orientation to be [1,1], meaning go down and to the right as you leave this element.
			</p>

					</li>
				</ul>
			</p>

		<a id="dynamicAnchors"><h3>Dynamic Anchors</h3></a>
	These are Anchors that can be positioned in one of a number of locations, choosing the one that is most appropriate each time something moves or is painted in the UI.
	<p>
	You create a dynamic anchor like this:
	</p>
<div class="code">
<pre>
var anchors = [jsPlumb.makeAnchor(0.2, 0, 0, -1), jsPlumb.makeAnchor(1, 0.2, 1, 0), 
			   jsPlumb.makeAnchor(0.8, 1, 0, 1), jsPlumb.makeAnchor(0, 0.8, -1, 0) ];
			   				
var dynamicAnchor = jsPlumb.makeDynamicAnchor(anchors);
</pre>
</div>	
You can then use that anchor as you would any other.  But note that you <strong>cannot share</strong> dynamic anchors between connections: dynamic anchors maintain 
state about the connection they belong to, so if you share one amongst two or more connections you will get unexpected results.
<h4>Default Dynamic Anchor</h4>
jsPlumb provides a 'default' dynamic anchor that chooses from TopCenter, RightMiddle, BottomCenter and LeftMiddle:
<div class="code">
<pre>var aDefaultDynamicAnchor = new jsPlumb.Anchors.AutoDefault();</pre>
</div>
Remember again that you <strong>must</strong> instantiate one of these - you cannot treat it as a static object.  See the note above.
<h4>Location Selection</h4>
The initial implementation of the algorithm that decides which location to choose just calculates which location is closest to the center of the 
other element in the connection.  It is possible that future versions of jsPlumb could support more sophisticated choice algorithms, if the need arose.
<h4>Draggable Connections</h4>
Dynamic Anchors and Draggable Connections can interoperate: jsPlumb locks the position of a dynamic anchor when you start to drag a connection from it,
and unlocks it once the connection is either established or abandoned. At that point you may see the position of the dynamic anchor change, as jsPlumb
optimises the connection.  <p>You can see this behaviour in the <a href="../html/jquery/draggableConnectorsDemo.html" target="_blank">draggable connections</a> demonstration, when
you drag a connection from the blue endpoint on window 1 to the blue endpoint on window 3 - the connection is established and then window 1's blue
endpoint jumps down to a location that is closer to window 3.</p> 	  
					</div>
												

		<div class="section">
			<a id="connectors"><h3>Connectors</h3></a>
			Connectors are the lines that actually join elements of the UI.  jsPlumb has two connector implementations - a straight line and a Bezier curve.  The default connector is the Bezier curve.
			<p>jsPlumb attaches the CSS class <em>_jsPlumb_connector</em> to Connectors that it generates.</p>
				<h4><a id="bezierConnector">Bezier Connector</a></h4>
				<p>The Bezier Connector provides a Bezier path between the two endpoints.  You construct one like this:
				<br/><br/>
				var myConnector = new jsPlumb.Connectors.Bezier(curviness);<br/><br/>
				<strong>curviness</strong>, which is optional (and defaults to 150), defines the distance in pixels that
				the Bezier's control points are situated from the anchor points.  This does not mean that your
				connector will pass through a point at this distance from your curve.  It is a hint to how you want the
				curve to travel. Rather than discuss Bezier curves at length here, because they are a very complex topic,
				we refer you to <a href="http://en.wikipedia.org/wiki/B%C3%A9zier_curve" target="_blank">Wikipedia.</a>
				</p>
				<h4><a id="straightConnector">Straight Connector</a></h4>
				<p>The Straight Connector draws a straight line between the two endpoints.  You construct one like this:
				<br/><br/>
				var myConnector = new jsPlumb.Connectors.Straight();<br/><br/>
				</p>
			<p>
			<h4><a id="connectorOverlays">Connectors and Overlays</a></h4>
			The section below this discusses Overlays, a new concept introduced in jsPlumb 1.2.3 that allows you to decorate Connectors with
			things such as labels or arrows or whatever else you like. Overlays can only work with Connectors that implement a few helper functions.
			<h4>The concept of <strong>location</strong></h4>
			Before discussing the helper functions you first must be across the concept of 'location' as used by this mechanism.  The <em>location</em>
			on a connector can be a decimal value between 0 and 1 inclusive, which marks a proportionate amount of travel <em>along the path
			inscribed by the Connector</em>.  For a straight line connector this is a simple piece of maths, but for Bezier connectors it's a little
			bit more involved.
			<h4>Required Helper Methods</h4>
			<ul>
				<li><strong>pointOnPath(location)</strong> - returns an [x,y] point corresponding to the given location</li>
				<li><strong>pointAlongPathFrom(location, distance)</strong> - returns an [x,y] point corresponding to travelling 'distance' pixels along the connector from 'location'.</li>
				<li><strong>gradientAtPoint(location)</strong> - returns the connector's gradient at the given location.  For linear connectors such as Straight this is constant, but for Bezier connectors the gradient changes continually.</li>
				<li><strong>perpendicularToPathAt(location, distance, length)</strong> - returns a line that is perpendicular to (and centered on) the connector at 'distance' from the given location, with length 'length'.</li>
			</ul>
			
			
			<h4><a id="customConnectors">Custom Connectors</a></h4>
			You can provide your own connectors if you need to. A Connector consists of two functions, which work as a pair.  First a call is made to the <em>compute</em> function:

			<div class="code">
<pre>
this.compute = function(sourcePos, targetPos, sourceAnchor, targetAnchor, lineWidth) {
	...
	return dimensions;
}
</pre>
			</div>
			which is expected to return a list that the <em>paint</em> function can make sense of.  The first four entries in the
			list <strong>must be</strong> the [x,y,width,height] values for the canvas that the connector will be drawn on; jsPlumb will
			use this information to size the canvas prior to calling the Connector's <em>paint</em> function.  Therefore it
			is the Connector's responsibility to ensure that the returned dimensions describe a large enough space for
			the line that will be drawn on it.</p><p>The next four elements <strong>must be</strong> the coordinates of the two endpoints of the line
			you are going to draw.</p><p>The remainder of the items in the returned list are arbitrary, and will
			vary between Connector implementations; this list is passed in to a Connector's <em>paint</em> function, so each
			implementation will put into the list whatever it needs to paint itself.  For instance, the straight line
			connector only needs the [x,y] location of each end of the line it will paint, and that is one of the required entries, so
			it does not have to do anything extra,  whereas the Bezier connector adds the location of the two control points.  Other types of
			Connectors will do whatever is appropriate for their particular situation.
			</p>
			This is the method signature for the <em>paint</em> function:
			<div class="code">
				<pre>this.paint = function(dimensions, ctx) { .. }</pre>
			</div>

			here, the 'dimensions' argument to the 'paint' function is the return value of the 'compute' function.  The 'ctx' argument is the Canvas context; you
			will do all your drawing on this.
			</p>
			To change the connector from the default, specify it in your connect call:
			<div class="code">
				<pre>jsPlumb.connect({source:'someWindow', target:'otherWindow', connector:new jsPlumb.Connectors.Straight()});</pre>
			</div>
		</div>
		
		<div class="section">
			<a id="overlays"><h3>Overlays</h3></a>
			<p>
			Overlays are UI elements that are painted onto connections, such as images, labels or arrows.
			jsPlumb comes with five defaults:
			<ul>
				<li>Arrow - a configurable arrow that is painted at some point along the connector.  You can control the length and width of the Arrow,
				as well as the 'foldback' point - a point the tail points fold back into.</li>
				<li>Label - a configurable label that is painted at some point along the connector</li>
				<li>PlainArrow - an Arrow shaped as a triangle, with no foldback.</li>
				<li>Diamond - as the name suggests, a diamond.</li>
				<li>Image - an image overlay.</li>
			</ul> 
			The last two are actually just configured instances of the generic Arrow overlay (see examples below). 
			</p>
			<h4>Connector Support</h4>
			Overlays can only work with Connectors that implement the methods <strong>pointOnPath</strong>, <strong>pointAlongPathFrom</strong>,
			<strong>gradientAtPoint</strong>, and <strong>perpendicularToPathAt</strong>.  These are discussed in more detail in the Connectors section above.  Both of the Connectors
			that come with jsPlumb - Straight and Bezier -implement these methods; if you write a custom connector, or have written a custom connector, you will need to supply
			them.   
			<h4>Overlay Interface</h4>
			An Overlay is required to implement two methods in order to be usable by jsPlumb:
			<ul>
				<li><strong>computeMaxSize(connector, context)</strong> - returns an integer value indicating the larger of this overlay's width and height.  It is used by jsPlumb to ensure that the canvas is large enough to accomodate the overlay.  The examples below should help to clarify this.</li>
				<li><strong>draw(connector, ctx)</strong> - draws the overlay.  What happens in this method is up to the given implementation.</li>
			</ul>
			<h4>computeMaxSize methods</h4>
			This is the Arrow overlay's computeMaxSize method:
			<div class="code">
<pre>
this.computeMaxSize = function() { return width; }
</pre>			
			</div>
Here, <em>width</em> is a private member of Arrow that indicates the width of the arrow's tail.  So the Arrow overlay reports that figure as the width it needs.					
Contrast this with the Label Overlay's computeMaxSize method:
		<div class="code">
<pre>
this.computeMaxSize = function(connector, ctx) {
  	if (labelText) {
  		ctx.save();
        if (self.labelStyle.font) ctx.font = self.labelStyle.font;
         var t = ctx.measureText(labelText).width;			            
		// a fake text height measurement: use the width of upper case M
		var h = ctx.measureText("M").width;					
		labelPadding = self.labelStyle.padding || 0.25;
		labelWidth = t + (2 * t * labelPadding);
		labelHeight = h + (2 * h * labelPadding);
		ctx.restore();
		return Math.max(labelWidth, labelHeight);
  	}
 	return 0;
 };
</pre>			
			</div>
The Label overlay has to use the context to determine how big it will be on screen.

<h4>draw methods</h4>
To give you a taste for how you can interact with a connector, consider the first few lines of the Arrow overlay's draw method:
<div class="code">
<pre>
this.draw = function(connector, ctx) {
	// this is the arrow head position
	var hxy = connector.pointAlongPathFrom(self.loc, length / 2);		
	// this is the center of the tail
	var txy = connector.pointAlongPathFrom(self.loc, -length / 2), tx = txy[0], ty = txy[1];
	// this is the tail vector
	var tail = connector.perpendicularToPathAt(self.loc, -length / 2, width);
	
	...
</pre>
</div>
	<p>The first two calls to the connector use the <strong>pointAlongPathFrom</strong> method, which passes <em>self.loc</em> as the location of the
	point on the path, and <em>length / 2</em> as the number of pixels along the path to traverse.</p>
	<p><em>self.loc</em> is Arrow's internal member describing the location of the overlay, and it is a decimal (between 0 and 1 inclusive) that points to
	a location at some distance along the path inscribed by the connector.  So these first two calls get us [x,y] locations of points on 
	the connector that mark the head and tail points for the arrow.  
	</p>		
	<p>
	The <strong>connector.perpendicularToPathAt(self.loc, -length / 2, width)</strong> call returns a line description of a line that is perpendicular to, and centered on, the connector
	at "-length / 2" pixels from the given point, with the given width (width is an internal member of Arrow).  At this point, the Arrow object has the three main points it
	needs in order to draw itself.
	</p>
	
	
		</div>
		<div class="section">
			<a id="endpoints"><h3>Endpoints</h3></a>
			<p>An Endpoint is the UI component that marks the location of an Anchor, ie. the place where a Connector joins an
			element.  jsPlumb comes with three Endpoint implementations - Dot, Rectangle and Image.
				<ul>
					<li>jsPlumb.Endpoints.Dot
						<p>This draws a dot.  Example constructor:
<div class="code">
<pre>
var myDot = new jsPlumb.Endpoints.Dot({radius:34});
</pre>
</div>
Here we created a dot with a radius of 34 pixels.  You do not need to supply the radius though - if you omit it, jsPlumb will assign a default of 10 pixels.  Note that you can also supply the radius in the endpointStyle object.
						</p><p>
						In the <em>endpointStyle</em> option of a <em>plumb</em> call, you can set two values
						that this will pick up:
							<ul>
								<li>radius - the radius of the dot (in pixels)</li>
								<li>fillStyle - the style to use when filling the dot.  If this is blank, jsPlumb will
								attempt to use the strokeStyle from the associated Connector.</li>
							</ul>
							<br/>
						</p>
					</li>
					<li>jsPlumb.Endpoints.Rectangle
						<p>Draws a rectangle.  Example constructor:
<div class="code">
<pre>
var myRect = new jsPlumb.Endpoints.Rectangle({width:34, height:10});
</pre>
</div>
Here we created a rectangle of size 34x10.  If you omit the size when you create a Rectangle, jsPlumb will use defaults of 20x20.  Just like with the Dot endpoint, you can also provide this information in the endpointStyle.
</p><p>
						In the <em>endpointStyle</em> you can set the following for this:
							<ul>
								<li>width - optional, defaults to 20.</li>
								<li>height - optional, defaults to 20.</li>
								<li>fillStyle - the style to use when filling the rectangle.  If this is blank, jsPlumb will
								attempt to use the strokeStyle from the associated Connector.</li>
							</ul>
							<br/>
						</p>
					</li>
					<li>jsPlumb.Endpoints.Image
						<p>Draws an image from a given URL.  Example constructor:
<div class="code">
<pre>
var myImage = new jsPlumb.Endpoints.Image({url:"http://myserver.com/images/endpoint.png"});
</pre>
</div>
This creates an Image endpoint with the image at the given url.  You do not need to provide dimensions.  jsPlumb will figure that out for you.
						</p>
					</li>
				</ul>
			</p>
			<p>To create your own Endpoint implementation, you need to implement a single method:
				<div class="code"><pre>paint : function(anchorPoint, orientation, canvas, endpointStyle, connectorPaintStyle) { ... }</pre></div>
				The arguments to this method are as follows:
				<ul>
					<li>anchorPoint - [x,y] location of the anchor point on screen</li>
					<li>orientation - [x,y] hints for the general direction the anchor points to</li>
					<li>canvas - the canvas to draw into</li>
					<li>endpointStyle - Javascript object containing style directives as discussed above.  The contents of this are arbitrary, so if you write a new Endpoint that needs some extra settings, you can add them no hassle.</li>
					<li>connectorPaintStyle - the style being used to paint the associated Connector.</li>
				</ul>
			</p>
			<p>
				It is your responsibility to size and locate the canvas to suit your needs. jsPlumb provides the following
				helper method to assist you:
				<div class="code"><pre>jsPlumb.sizeCanvas(canvas, x, y, width, height);</pre></div>
				Allows you to locate the canvas on screen and to size it.
			</p>
			<a id="endpointOperations"><h4>Endpoint Operations</h4></a>
			These are the methods supported by the Endpoint class:
			<ul>
<li><p>removeConnection</p>
This method is <em>deprecated</em>; it has been renamed to <strong>detach</strong>
</li>
<li><p>detach</p>
Removes a Connection from the Endpoint.  The Connection will have been returned from a call to <strong>jsPlumb.connect</strong>.  
<div class="code">
<pre>
var c = myEndpoint.addConnection({...});

...
time passes
...

myEndpoint.detach(c);
</pre>
</div>
</li>
<li><p>detachAll</p>
Removes all Connections from the Endpoint.  
<div class="code">
<pre>
var c = myEndpoint.addConnection({...});
var c2 = myEndpoint.addConnection({...});

...
time passes
...

myEndpoint.detachAll();
</pre>
</div>
</li>
<li><p>detachFrom</p>
Detaches all Connections from this Endpoint to some other Endpoint.
<div class="code">
<pre>
var c = myEndpoint.addConnection({...});
var c2 = myOtherEndpoint.addConnection({...});
jsPlumb.connect({sourceEndpoint:c, targetEndpoint:c2});

...
time passes
...

myEndpoint.detachFrom(myOtherEndpoint);
</pre>
</div>
</li>
<li>
	<p>getElement</p>
Returns the DOM element the Endpoint is attached to.	
</li>
<li>
<p>isConnectedTo</p>
Returns whether or not this Endpoint is connected to some other Endpoint.
<div class="code">
<pre>
var c = myEndpoint.addConnection({...});
var c2 = myOtherEndpoint.addConnection({...});
jsPlumb.connect({sourceEndpoint:c, targetEndpoint:c2});

var isConnected = c.isConnectedTo(c2);				// returns true
</pre>
</div>
</li>
<li>
	<p>isFull</p>
	Returns whether or not the Endpoint can accept any more Connections.  This is determined by the parameters
	passed in to the addEndpoint call, specifically the 'maxConnections' value: by default this is set to 1. You
	can provide any positive value for this, or -1 if you wish to have no maximum.
</li>
<li>
	<p>getUuid</p>
	Returns the Endpoint's UUID, if one was provided when the Endpoint was created.  See also
	<strong>jsPlumb.getEndpoint(uuid)</strong> and <strong>jsPlumb.connect</strong>.
</li>
<li>
	<p>setDragAllowedWhenFull</p>
	Sets whether or not connections can be dragged from the Endpoint once it is full.  Use this in conjunction
	with the 'reattach' option on a connect call - if this is true, you can specify whether or not dropped
	connections reattach or are removed.
</li>
			</ul>
	<a id="endpointUuids"><h4>Endpoint UUIDs</h4></a>
	Each Endpoint can have a UUID associated with it; these can be used to establish Connections and
	also to retrieve Endpoints from jsPlumb.  To assign a UUID to an Endpoint you can do one of two things:
	
	<ul>
	<li>
	Nominate the UUID in a call to jsPlumb.addEndpoint (when creating an Endpoint you will use later):
<div class="code">
<pre>
jsPlumb.addEndpoint("someElement", {uuid:"abcdefg"});
</pre>
</div>		
	</li>
	<li>Nominate two UUIDs in a call to jsPlumb.connect (Endpoints will be created and have these UUIDs assigned):
<div class="code">
<pre>
jsPlumb.connect({uuids:["abcdefg", "hijklmn"], source:"someElement", target:"someOtherElement"});
</pre>
</div>		
	</li>
	</ul>
	
	Once you have an Endpoint that has a UUID assigned, you can retrieve it from jsPlumb:
<div class="code">
<pre>
var e = jsPlumb.getEndpoint("abcdefg");
</pre>
</div>	
...and you can also use the UUIDs to connect Endpoints:
<div class="code">
<pre>
jsPlumb.connect({uuids:["abcdefg", "hijklmn"});
</pre>
</div>		

			
		</div>

		<div class="section">
			<a id="gradients"><h3>Gradients</h3></a>
			The Canvas element supports gradients, and jsPlumb can take advantage of this when painting your Connectors
			and/or Endpoints.  <strong>Note:</strong> this does <strong>NOT WORK in IE</strong>, because we use ExplorerCanvas in IE
			and ExplorerCanvas does not support gradients.
			<p>There are two types of gradients available in Canvas - a 'linear' gradient, which consists of colored lines all
			going in one direction, and a 'radial' gradient, which consists of colored circles emanating from one circle to another.
			Because of their basic shape, jsPlumb supports only <em>linear</em> gradients for
			Connectors.  But for Endpoints, jsPlumb supports both <em>linear</em> and <em>radial</em> gradients.</p>
			<p>
				<h4>Connector gradients</h4>
				To specify a linear gradient to use in a Connector, you must add a <em>gradient</em> object to your
				Connector's <em>paintStyle</em>, for instance:
<div class="code">
<pre>jsPlumb.connect({
	source : 'window2',
	target : 'window3',
	paintStyle:{
		gradient:{
			stops:[[0,'green'], [1,'red']]
		},
		lineWidth:15
	}
});
</pre>
</div>
Here we have connected window2 to window3 with a 15 pixel wide connector that has a gradient from green to red.</p><p> Notice the <strong>gradient</strong> object and the
<strong>stops</strong> list inside it - the gradient consists of an arbitrary number of these "color stops".  Each color stop is comprised
of two values - [position, color].  Position must be a decimal value between 0 and 1 (inclusive), and indicates where the color
stop is situated as a fraction of the length of the entire gradient.  Valid values for
the colors in the <strong>stops</strong> list are the same as those that are valid for <strong>strokeStyle</strong> when describing a color.
			</p>
			<p>As mentioned, the <strong>stops</strong> list can hold an arbitrary number of entries.  Here's an example of a gradient that goes from red to blue to green, and back again through blue to red:
<div class="code">
<pre>jsPlumb.connect({
	source : 'window2',
	target : 'window3',
	paintStyle : {
		gradient:{
			stops:[[0,'red'], [0.33,'blue'], [0.66,'green'], [0.33,'blue'], [1,'red']]
		},
		lineWidth : 15
	}
});
</pre>
</div>
<strong>Note:</strong> jsPlumb uses ExplorerCanvas for IE, which does not support gradients.  On IE, jsPlumb will simply ignore the gradient directive
so it is best to ensure you also supply a <em>strokeStyle</em> in your paintStyle object, to give jsPlumb something to fall back on.  If you do not supply
a <em>strokeStyle</em> your Connectors will be painted black.  The previous example might look like this, for instance:
<div class="code">
<pre>jsPlumb.connect({
	source : 'window2',
	target : 'window3',
	paintStyle:{
		strokeStyle:'red',
		gradient:{
			stops:[[0,'red'], [0.33,'blue'], [0.66,'green'], [0.33,'blue'], [1,'red']]
		},
		lineWidth:15
	}
});
</pre>
</div>
Notice the <strong>strokeStyle:'red'</strong> directive at the beginning of the parameter list in <strong>paintStyle</strong>.
			</p>
			<h4>Endpoint gradients</h4>
			Endpoint gradients are specified using the same syntax as Connector gradients.  You put the gradient specifier either in the
			<strong>endpoint</strong> member, or if you are specifying different Endpoints for each end of the Connector, in one or both of
			the values in the <strong>endpoints</strong> array.  Also, this information applies to the case that you are creating standalone
			Endpoints that you will be configuring for drag and drop creation of new Connections. 
			<p>
			This is an example of an Endpoint gradient that is different for each Endpoint in the Connector.  This comes from the main demo; it is
			the Connector joining Window 2 to Window 3:
			</p>
<div class="code">
<pre>var w23Stroke = 'rgb(189,11,11)';
jsPlumb.connect({
	source : 'window2',
	target : 'window3',
	paintStyle:{
		lineWidth:8,
		strokeStyle:w23Stroke
	},
 	anchors:[ [0.3,1,0,1], "TopCenter" ],
 	endpoint:new jsPlumb.Endpoints.Rectangle(),
 	endpointStyles:[
 		{ gradient : {stops:[[0, w23Stroke], [1, '#558822']] } },
    	{ gradient : {stops:[[0, w23Stroke], [1, '#882255']] } }
    ]
});
</pre>
</div>
The first entry in the gradient will be the one that is on the Connector end of the Endpoint.  You can of course have as many color stops as
you want in this gradient, just like with Connector gradients.
	<h5>Applying the gradient in Endpoints</h5>
	Only the Dot and Rectangle endpoints honour the presence of a gradient (and, remember, not in IE). The Image endpoint of course ignores a gradient
	as it does no painting of its own.
	<p>The type of gradient you will see depends on the Endpoint type:
		<ul>
			<li>Dot - renders a radial endpoint, with color stop 0 on the outside, progressing inwards as we move through color stops.
			<p>Radial gradients actually require more data than linear gradients - in a linear gradient we just move from one point to another, whereas
			in a radial gradient we move from one <em>circle</em> to another.  By default, jsPlumb will render a radial gradient using a source
			circle of the same radius as the Endpoint itself, and a target circle of 1/3 of the radius of the Endpoint (both circles share the
			same center as the Endpoint itself). This circle will be offset by radius/2 in each direction.</p>
			<p>You can supply your own values for these inside the gradient descriptor:</p>
<div class="code">
<pre>var w34Stroke = 'rgba(50, 50, 200, 1)';
var w34HlStroke = 'rgba(180, 180, 200, 1)';
jsPlumb.connect({
	source : 'window3',
	target : 'window4',
    paintStyle:{
    	lineWidth:10,
    	strokeStyle:w34Stroke
    },
    anchors:[ jsPlumb.Anchors.RightMiddle, jsPlumb.Anchors.LeftMiddle ],
    endpointStyle:{
    	gradient : {
    		stops:[ [0, w34Stroke], [1, w34HlStroke] ],
    		offset:37.5,
    		innerRadius:40
    	},
    	radius:55
    }
 });
</pre>
</div>
Here we have instructed jsPlumb to make the gradient's inner radius 10px instead of the default 25/3 = 8 ish pixels, and the offset in each direction
will be 5px, instead of the default radius / 2 = 12.5 pixels.
<p>It is also possible to specify the offset and inner radius as percentages - enter the values as strings with a '%' symbol on the end:</p>
<div class="code">
<pre>var w34Stroke = 'rgba(50, 50, 200, 1)';
var w34HlStroke = 'rgba(180, 180, 200, 1)';
jsPlumb.connect({
	source : 'window3', 
	target : 'window4',
    paintStyle:{
    	lineWidth:10,
    	strokeStyle:w34Stroke
    },
	anchors:[ jsPlumb.Anchors.RightMiddle, jsPlumb.Anchors.LeftMiddle ],
	endpointStyle:{
		gradient : {
			stops:[ [0, w34Stroke], [1, w34HlStroke] ],
			offset:'68%',
			innerRadius:'73%'
		},
		radius:25
	}
});
</pre>
</div>
This will give roughly the same output as the example above (the percentages are not entirely exact).
			</li>
			<li>Rectangle - renders a linear endpoint, with color stop 0 closest to the end of the Connector</li>
		</ul>
	</p>
		</div>
		
		<div class="section">
			<a id="animation"><h3>Animation</h3></a>
			jsPlumb offers an 'animate' function, which wraps the underlying animation engine for whichever library you happen to be using and
			inserts a callback for jsPlumb to repaint whatever it needs to at each step.  You could of course do this yourself; it's a convenience
			method really.
			<p>The method signature is:</p>
<div class="code">
<pre>
jsPlumb.animate : function(el, properties, options) 
</pre>
</div>			
The arguments are as follows:
	<ul>
		<li>el - element id, or element object from the library you're using.</li>
		<li>properties - properties for the animation, such as duration etc.</li>
		<li>options - options for the animation, such as callbacks etc.</li>
	</ul>
	
		</div>
		
		<div class="section">
			<a id="events"><h3>Events</h3></a>
			As of version 1.2.2, jsPlumb fires an event to registered listeners whenever a connection
			is made.  We plan to support more events in the future.
			<h4>Registering Event Listeners</h4>
			To register an event listener you need to supply the event name and a listener object:
<div class="code">
<pre>
jsPlumb.addListener("jsPlumbConnection", someListener); 
</pre>
</div>
The listener object - in this case 'someListener' - must have a method with the same name as the event. For example, to define
a listener inline, you could do a call like this:
<div class="code">
<pre>
jsPlumb.addListener("jsPlumbConnection", {
	jsPlumbConnection:function(data) {
		alert("a connection was made from " + data.sourceId + " to " + data.targetId);
	}
}); 
</pre>
</div>
It is also possible to register a single listener for multiple event types - just pass in the event types as an array of Strings:
<div class="code">
<pre>
jsPlumb.addListener(["jsPlumbConnection","jsPlumbConnectionDetached"], {
	jsPlumbConnection:function(data) {
		alert("a connection was made from " + data.sourceId + " to " + data.targetId);
	},
	jsPlumbConnectionDetached:function(data) {
		alert("a connection was detached from " + data.sourceId + " to " + data.targetId);
	}
}); 
</pre>
</div>
		<h4>Event Types</h4>
		<table>
			<tr><th>event name</th><th>function arguments</th><th>explanation</th></tr>
			<tr><td>jsPlumbConnection</td><td>params - JS object containing sourceId, targetId, source, target, sourceEndpoint, targetEndpoint</td><td>fired whenever a new connection is made, either programmatically via jsPlumb.connect, or drag and drop</td></tr>
			<tr><td>jsPlumbConnectionDetached</td><td>params - JS object containing sourceId, targetId, source, target, sourceEndpoint, targetEndpoint</td><td>fired whenever a connection is detached, either programmatically via one of the jsPlumb.detach methods, or drag and drop</td></tr>
		</table>
			
		
		</div>

		<div class="section">
			<a id="cssclasses"><h3>CSS Class Reference</h3></a>
			jsPlumb attaches classes to each of the UI components it creates:
			<table>
				<tr><th>component</th><th>css class</th></tr>
				<tr><td>connector</td><td>_jsPlumb_connector</td></tr>
				<tr><td>endpoint</td><td>_jsPlumb_endpoint</td></tr>
			</table>
			You would typically use these to establish appropriate z-indices for your UI.
		</div>

		
		
				<div class="section">
			<a id="examples"><h3>Basic Examples</h3></a>
			These examples are all for creating a static interface, ie. one in which you cannot
			drag to create new Connections.  See <a href="#dragAndDropExamples">Draggable Connections Examples</a>
			if that's what you're looking for.
			<p>
			The basic syntax of a call is that you execute 'connect', providing a source and a target, and optionally a paintStyle and preferences for where you
			want the plumbing to be anchored on each element, as well as the type of connector to use. Note that in all of the following examples,
			if you are using jQuery, you can substitute <strong>jsPlumb.connect</strong> with <strong>$('#someElement').plumb</strong>, where 'someElement'
			is the id of the element you would pass as 'source' to the connect call.
			</p>
			<ul>
				<li>Connect window1 to window2 with the default settings:
					<div class="code">
						<pre>jsPlumb.connect({source:'window1', target:'window2'});</pre>
					</div>
				</li>
				<li>Connect window1 to window2 with a 15 pixel wide yellow plumb line, and a slightly brighter endpoint:
					<div class="code">
<pre>jsPlumb.connect({
	source:'window1',
	target:'window2',
	paintStyle:{lineWidth:15,strokeStyle:'rgb(243,230,18)'},
	endpointStyle:{fillStyle:'rgb(243,229,0)'}
});</pre>
					</div>
				</li>
				
				<li>Connect window1 to window2 with a 15 pixel wide yellow plumb line, and a slightly brighter endpoint, and tell jsPlumb that the scope of this connection is 'connectorType1' (see <a href="#dragAndDropScope">here</a>):
					<div class="code">
<pre>jsPlumb.connect({
	source:'window1',
	target:'window2',
	paintStyle:{lineWidth:15,strokeStyle:'rgb(243,230,18)'},
	endpointStyle:{fillStyle:'rgb(243,229,0)'},
	scope:'connectorType1'
});</pre>
					</div>
				</li>				
				<li>Connect window3 to 'window4' with a 10 pixel wide, semi opaque blue plumb line, anchored to the left middle of window3, and the right middle of window4, with an endpoint of radius 25:
					<div class="code">
<pre>jsPlumb.connect({
	source:'window3',
	target:'window4',
	paintStyle:{lineWidth:10, strokeStyle:'rgba(0, 0, 200, 0.5)'},
	anchors:[jsPlumb.Anchors.RightMiddle, jsPlumb.Anchors.LeftMiddle],
	endpointStyle:{radius:25}
});</pre>
					</div>
				</li>
				<li>Connect window2 to window3 with a default plumb line from the top center of window2 to the bottom center of window3, and rectangular endpoints:
					<div class="code">
<pre>jsPlumb.connect({
	source:'window2',
	target:'window3',
	paintStyle:{lineWidth:8, strokeStyle:'rgb(189,11,11)'},
	anchors:[jsPlumb.Anchors.BottomCenter, jsPlumb.Anchors.TopCenter],
	endpoint:new jsPlumb.Endpoints.Rectangle()
});</pre>
					</div>
				</li>


				<li>Connect window1 to window2 with a 15 px wide yellow Bezier. endpoints are a slightly lighter shade of yellow.
<div class="code">
<pre>jsPlumb.connect({
	source:'window1',
	target:'window2',
	anchors:["BottomCenter", [0.75,0,0,-1]],
	paintStyle:{lineWidth:15,strokeStyle:'rgb(243,230,18)'},
	endpointStyle:{fillStyle:'rgb(243,229,0)'}
});</pre>
</div></li>
<li>Connect window3 to window4 with a 10px wide blue-ish half transparent Bezier. put endpoints underneath the element they attach to.
the endpoints have a radial gradient. both ways of specifying gradient positioning are shown here.
<div class="code">
<pre>var w34Stroke = 'rgba(50, 50, 200, 1)';
var w34HlStroke = 'rgba(180, 180, 200, 1)';
jsPlumb.connect( {
	source:'window3',
	target:'window4',
		 paintStyle:{lineWidth:10, strokeStyle:w34Stroke},
		 anchors:[jsPlumb.Anchors.RightMiddle, jsPlumb.Anchors.LeftMiddle],
		 endpointStyle:{ gradient : {stops:[[0, w34Stroke], [1, w34HlStroke]], offset:17.5, innerRadius:15 }, radius:35},
		 //endpointStyle:{ gradient : {stops:[[0, w34Stroke], [1, w34HlStroke]], offset:'78%', innerRadius:'73%'}, radius:35 },
		 endpointsOnTop:false
	}
);</pre>
</div></li>
<li>Connect window2 to window3 with an 8px red Bezier and default rectangular endpoints.  see also how the first anchor is
specified here - this is how you create anchors in locations jsPlumb does not offer shortcuts for.
the endpoints in this example have linear gradients applied.
<div class="code">
<pre>var w23Stroke = 'rgb(189,11,11)';
jsPlumb.connect({
	source:'window2',
	target:'window3',
	paintStyle:{lineWidth:8,strokeStyle:w23Stroke},
	anchors:[[0.3,1,0,1], "TopCenter"],
	endpoint:new jsPlumb.Endpoints.Rectangle(),
	endpointStyles:[{ gradient : {stops:[[0, w23Stroke], [1, '#558822']] }},
       				{ gradient : {stops:[[0, w23Stroke], [1, '#882255']] }}]
});</pre>
</div></li>

<li>Connect window5 to window6 from center to center, 5px wide line that is green and half transparent. the endpoints are
125px in radius and spill out from underneath their elements.
<div class="code">
<pre>jsPlumb.connect({
	source:'window5',
	target:'window6',
	anchors:[jsPlumb.Anchors.Center, jsPlumb.Anchors.Center],
	paintStyle:{lineWidth:5,strokeStyle:'rgba(0,255,0,0.5)'},
	endpointStyle:{radius:125}
});</pre>
</div></li>

<li>Connect window4 to window5 from bottom right to top left, with a 7px straight line purple connector, and an image as the endpoint,
placed on top of the element it is connected to.
<div class="code">
<pre>jsPlumb.connect({
	source:'window4',
	target:'window5',
	anchors:[jsPlumb.Anchors.BottomRight,jsPlumb.Anchors.TopLeft],
	paintStyle:{lineWidth:7,strokeStyle:'rgb(131,8,135)'},
	endpoint:new jsPlumb.Endpoints.Image({url:"http://morrisonpitt.com/jsPlumb/img/endpointTest1.png"}),
	connector:new jsPlumb.Connectors.Straight()
});</pre>
</div></li>


				<li>Connect window5 to window6 between their center points with a semi-opaque connector, and 125px endpoints:
					<div class="code">
<pre>jsPlumb.connect({
	source:'window5',
	target:'window6',
	anchors:[jsPlumb.Anchors.Center, jsPlumb.Anchors.Center],
	paintStyle:{lineWidth:5,strokeStyle:'rgba(0,255,0,0.5)'},
	endpointStyle:{radius:125}
});</pre>
					</div>
				</li>
				<li>Connect window7 to window8 with a 10 pixel wide blue plumb line, anchored on the top left of window7 and the bottom right of window8:
					<div class="code">
<pre>jsPlumb.connect({
	source:'window7',
	target:'window8',
	paintStyle:{lineWidth:10, strokeStyle:'blue'},
	anchors:[jsPlumb.Anchors.TopLeft, jsPlumb.Anchors.BottomRight]
});
</pre>
					</div>
				</li>
				<li>Connect the bottom right corner of window4 to the top left corner of window5, with rectangular endpoints of size 40x40:
					<div class="code">
<pre>jsPlumb.connect({
	source:'window4',
	target:'window5',
	anchors:[jsPlumb.Anchors.BottomRight,jsPlumb.Anchors.TopLeft],
	paintStyle:{lineWidth:7,strokeStyle:'rgb(131,8,135)'},
	endpointStyle:{width:40, height:40},
	endpoint:new jsPlumb.Endpoints.Rectangle(),
	connector:new jsPlumb.Connectors.Straight()
});</pre>
					</div>
				</li>
				<li>Connect window1 to window2 with the default paint settings but provide some drag options (which are passed through to jQuery's draggable call):
					<div class="code">
						<pre>jsPlumb.connect({source:'window1', target:'window2', dragOptions:{cursor:'crosshair'}});</pre>
					</div>
				</li>
				<!-- li>Detach window2 from window1
					<div class="code">
						<pre>$("#window2").detach("window1");</pre>
					</div>
				</li>
				<li>Detach window2 from window1 and window3
					<div class="code">
						<pre>$("#window2").detach(["window1", "window3"]);</pre>
					</div>
				</li-->
				<li>Detach window5 from all connections
					<div class="code">
						<pre>jsPlumb.detachAll("window5");</pre>
					</div>
				</li>
				<li>Hide all window5's connections
					<div class="code">
						<pre>jsPlumb.hide("window5");</pre>
					</div>
				</li>
				<li>Show all window5's connections
					<div class="code">
						<pre>jsPlumb.show("window5");</pre>
					</div>
				</li>
				<li>Toggle the visibility of window5's connections
					<div class="code">
						<pre>jsPlumb.toggle("window5");</pre>
					</div>
				</li>
				<li>Force repaint of all of window5's connections
					<div class="code">
						<pre>jsPlumb.repaint("window5");</pre>
					</div>
				</li>
				<li>Force repaint of all of window5, window6 and window11's connections
					<div class="code">
						<pre>jsPlumb.repaint( [ "window5", "window6", "window11" ] );</pre>
					</div>
				</li>
				<li>Force repaint of every connection
					<div class="code">
						<pre>jsPlumb.repaintEverything();</pre>
					</div>
				</li>
				<li>Detach every connection
					<div class="code">
						<pre>jsPlumb.detachEverything();</pre>
					</div>
				</li>
				<li>Remove the given Endpoint from element "window1" 
					<div class="code">
						<pre>jsPlumb.removeEndpoint("window1", someEndpoint);</pre>
					</div>
				</li>
				<li>Remove all Endpoints for the element 'window1'
					<div class="code">
						<pre>jsPlumb.removeAllEndpoints("window1");</pre>
					</div>
				</li>	
				<li>Removes every Endpoint managed by this instance of jsPlumb 
					<div class="code">
						<pre>jsPlumb.removeEveryEndpoint();</pre>
					</div>
				</li>
				<li>Clears this jsPlumb instance's cache of elements by id. You should call this if you remove elements from the DOM and then reattach them.  
					<div class="code">
						<pre>jsPlumb.clearCache();</pre>
					</div>
				</li>
				<li>Removes every endpoint, detaches every connection, and clears the element cache.  Returns jsPlumb instance to its initial state.  
					<div class="code">
						<pre>jsPlumb.reset();</pre>
					</div>
				</li>				
				<li>Set window1 to be not draggable, no matter what some plumb command may request.
					<div class="code">
						<pre>jsPlumb.setDraggable("window1", false);</pre>
					</div>
				</li>
				<li>Set window1 and window2 to be not draggable, no matter what some plumb command may request.
					<div class="code">
						<pre>jsPlumb.setDraggable(["window1","window2"], false);</pre>
					</div>
				</li>
				<li>Sets whether or not elements that are plumbed are draggable by default.
				The default for this is true.
					<div class="code">
						<pre>jsPlumb.setDraggableByDefault(false);</pre>
					</div>
				</li>
				<li>Initialises window1 as a draggable element (all libraries)
				<div class="code">
					<pre>jsPlumb.draggable("window1");</pre>
				</div>
				</li>
				<li>Initialises window1 and window2 as draggable elements (all libraries)
				<div class="code">
					<pre>jsPlumb.draggable(["window1","window2"]);</pre>
				</div>
				</li>
				<li>Initialises window1 as a draggable element (all libraries)
				<div class="code">
					<pre>jsPlumb.draggable("window1");</pre>
				</div>
				</li>
				<li>Initialises all elements with class 'window' as draggable elements (jQuery)
				<div class="code">
					<pre>jsPlumb.draggable($(".window"));</pre>
				</div>
				</li>
				<li>Initialises all elements with class 'window' as draggable elements (MooTools)
				<div class="code">
					<pre>jsPlumb.draggable($$(".window"));</pre>
				</div>
				</li>
				<li>Initialises window1 as a draggable element (jQuery)
				<div class="code">
					<pre>jsPlumb.draggable($("#window1"));</pre>
				</div>
				</li>
				<li>Initialises window1 as a draggable element (MooTools)
				<div class="code">
					<pre>jsPlumb.draggable($("window1"));</pre>
				</div>
				</li>
			</ul>
		</div>
		
		<div class="section">
			<a id="dragAndDropExamples"><h3>Draggable Connections Examples</h3></a>
			This is a list of examples of how to use jsPlumb to create Connections using drag and drop.
			<p>
			The basic procedure is:
			<ol>
				<li>Create Endpoints and register them on elements in your UI</li>
				<li>Drag and Drop</li>
			</ol>
			That's all there is to it.  Of course there are plenty of options you can set when doing this...it will be easier
			to show you some examples:
			</p>
			<ul>
				<li>Define an Endpoint with default appearance, that is both a source and target of new Connections:
<div class="code">
<pre>var endpointOptions = { isSource:true, isTarget:true }; 
</pre>
</div>				 				
				</li>
				
				<li>Register that Endpoint on window3, specifying that it should be located in the top center of the element:
<div class="code">
<pre>var window3Endpoint = jsPlumb.addEndpoint('window3', jsPlumb.extend({anchor:jsPlumb.Anchors.TopCenter}, endpointOptions}));  
</pre>
</div>
Notice here the usage of the 'extend' function - we can reuse 'endpointOptions' with a different Anchor for another element.  This is a useful
practice to get into. 				 				<br/><br/>
				</li>
				
				<li>Now register that Endpoint on window4, specifying that it should be located in the bottom center of the element:
<div class="code">
<pre>var window4Endpoint = jsPlumb.addEndpoint('window4', jsPlumb.extend({anchor:jsPlumb.Anchors.BottomCenter}, endpointOptions}));  
</pre>
</div>
Now we have two Endpoints, both of which support drag and drop of new Connections.  We can use these to make a programmatic Connection, too, though...<br/><br/>
				</li>				
				
				<li>Connect window3 to window4 with a 25px wide yellow Bezier that has a 'curviness' of 175:
<div class="code">
<pre>jsPlumb.connect({ 
	sourceEndpoint:window3Endpoint,
	targetEndpoint:window4Endpoint,
	connector: new jsPlumb.Connectors.Bezier(175),
	paintStyle:{lineWidth:25, strokeStyle:'yellow' }
});  
</pre>
</div>
				</li>
				
				<li>Define an Endpoint that creates Connections that are 20px wide straight lines, that is both a source and target of new Connections,
				and that has a 'scope' of 'blueline'. Also, this Endpoint mandates that once it is full, Connections can
				no longer be dragged from it (even if 'reattach' is specified on a Connection):
<div class="code">
<pre>var endpointOptions = { 
	isSource:true, 
	isTarget:true,
	connector : new jsPlumb.Connectors.StraightLine(),
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dragAllowedWhenFull:false	 
}; 
</pre>
</div>				 				
				</li>
				
<li>Define an Endpoint that is a 30px blue dot, creates Connections that are 20px wide straight lines, is both a source and target of new Connections,
				has a 'scope' of 'blueline', and has an event handler that pops up an alert (note: the event handler name means this example is jQuery - MooTools
				uses different event handler names):
<div class="code">
<pre>var endpointOptions = { 
	isSource:true, 
	isTarget:true,
	endpoint: new jsPlumb.Endpoints.Dot({radius:30}),
	style:{fillStyle:'blue'},
	connector : new jsPlumb.Connectors.StraightLine(),
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dropOptions:{ drop:function(e, ui) { alert('drop!'); } }	 
}; 
</pre>
</div>				 				
				</li>
				
			<li>Same example as before, but this is for MooTools, and the Endpoint can support up to 5 connections (the default is 1):
<div class="code">
<pre>var endpointOptions = { 
	isSource:true, 
	isTarget:true,
	endpoint: new jsPlumb.Endpoints.Dot({radius:30}),
	style:{fillStyle:'blue'},
	maxConnections:5,
	connector : new jsPlumb.Connectors.StraightLine(),
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dropOptions:{ onDrop:function(e, ui) { alert('drop!'); } }	 
}; 
</pre>
</div>				 				
				</li>
				
				<li>Same example again, but maxConnections being set to -1 means that the Endpoint has no maximum limit of Connections:
<div class="code">
<pre>var endpointOptions = { 
	isSource:true, 
	isTarget:true,
	endpoint: new jsPlumb.Endpoints.Dot({radius:30}),
	style:{fillStyle:'blue'},
	maxConnections:-1,
	connector : new jsPlumb.Connectors.StraightLine(),
	connectorStyle: { lineWidth:20, strokeStyle:'blue' },
	scope:"blueline",
	dropOptions:{ onDrop:function(e, ui) { alert('drop!'); } }	 
}; 
</pre>
</div>				 				
				</li>
	<li>Assign a UUID to the endpoint options created above, and add as Endpoints to "window1" and "window2":
<div class="code">
<pre>
jsPlumb.addEndpoint("window1", jsPlumb.extend({uuid:"abcdefg"}, endpointOptions));
jsPlumb.addEndpoint("window2", jsPlumb.extend({uuid:"hijklmn"}, endpointOptions));
</pre>
</div>	
	</li>
	
	<li>Connect the two Endpoints we just registered on "window1" and "window2":
<div class="code">
<pre>
jsPlumb.connect({uuids:["abcdefg", "hijklmn"]});
</pre>
</div>	
	</li>
				
			</ul>
		</div>
		
		<div class="section">
			<a id="connectionInfo"><h3>Retrieving Connection Information</h3></a>
			jsPlumb offers one fairly versatile method - <strong>getConnections</strong> - to retrieve information about the
			currently managed connections.  
			<p>Before you use this method you should understand jsPlumb's notion of 'scope' - documentation
			is <a href="#dragAndDropScope">here</a> </p>
			<p>
			getConnections optionally takes an object specifying filter parameters, of which there are three:
			<ul>
				<li>scope - the scope of the connection type(s) you wish to retrieve</li>
				<li>source - limits the returned connections to those that have this source id</li>
				<li>target - limits the returned connections to those that have this target id</li>
			</ul>			
			Each of these three parameters may be supplied as a string, or a list of strings - see the examples below.
			</p>
			<p>
			The return value of a call to getConnection is a dictionary whose keys are scope names,
			and whose values are lists of sourceId/targetId pairs, for example:
			
<div class="code">
<pre>
{
	"_jsPlumb_DefaultScope" : [
		{sourceId:"window1", targetId:"window2"},
		{sourceId:"window5", targetId:"window3"}
	],
	"someCustomScope": [
		{sourceId:"window6", targetId:"window2"},
		{sourceId:"window4", targetId:"window13"},
		{sourceId:"window2", targetId:"window10"}
	]
}
</pre>
</div>			
			</p>
		The following examples show the various ways you can call this method:
	<ul>
		<li>Get all connections:
			<div class="code">
<pre>
var c = jsPlumb.getConnections();  
</pre>
</div>						
		</li>
<li>Get all connections for the default scope only:
			<div class="code">
<pre>
var c = jsPlumb.getConnections(jsPlumb.getDefaultScope());  
</pre>
</div>						
		</li>
		<li>Get all connections for the given scope:
			<div class="code">
<pre>
var c = jsPlumb.getConnections({scope:"myTestScope"});  
</pre>
</div>						
		</li>
		<li>Get all connections for the given scopes:
			<div class="code">
<pre>
var c = jsPlumb.getConnections({scope:["myTestScope", "yourTestScope"]});  
</pre>
</div>						
		</li>
		<li>Get all connections for the given source:
			<div class="code">
<pre>
var c = jsPlumb.getConnections({source:"mySourceElement"});  
</pre>
</div>						
		</li>
		<li>Get all connections for the given sources:
			<div class="code">
<pre>
var c = jsPlumb.getConnections({source:["mySourceElement", "yourSourceElement"]});  
</pre>
</div>						
		</li>		
<li>Get all connections for the given target:
			<div class="code">
<pre>
var c = jsPlumb.getConnections({target:"myTargetElement"});  
</pre>
</div>						
		</li>				
<li>Get all connections for the given source and targets:
			<div class="code">
<pre>
var c = jsPlumb.getConnections({source:"mySourceElement", target:["target1", "target2"]});  
</pre>
</div>						
		</li>				
		
<li>Get all connections for the given scope, with the given source and target:
			<div class="code">
<pre>
var c = jsPlumb.getConnections({scope:'myScope", source:"mySourceElement", target:"myTargetElement"});  
</pre>
</div>						
		</li>				
		
	</ul>	
	Note that the return value is always a dictionary and not an array, even if you specified a single
	scope in the getConnections call.  So you always have to get the array you need by looking it up in the dictionary:
	
			<div class="code">
<pre>
var c = jsPlumb.getConnections({scope:"myScope", source:"mySourceElement"});
var conns = c["myScope"];  
</pre>
</div>					

The array <strong>may be null</strong>.  If you have not registered any connections with that scope, it will be.  Code defensively!

			
		</div>
		
		
		<div class="section">
			<a id="developingJsPlumb"><h3>Advanced: jsPlumb internals</h3></a>
			<h4><a id="fileBreakdown">Which files are which?</a></h4>
			In development, jsPlumb is broken up into four main scripts:
				<ul>
					<li>jsPlumb-X.X.js
					<p>This is the main jsPlumb engine.  It calls out to the underlying library implementation, and it has no Anchors, Endpoints or Connections specified.</p>					
					</li>
					<li>jsPlumb-defaults-x.x.js
					<p>This contains the default Anchor, Endpoints and Connections implementations</p>
					</li>
					<li>&lt;LIBRARY_PREFIX&gt;.jsPlumb-X.X.js
					<p>This contains library-specific helper methods.  jsPlumb ships with two of these - one for jQuery and one for MooTools. See below for information on how to create a new library implementation.</p>
					</li>
					<li>&lt;jsBezier-0.1.js&gt;</li>
					<p>These are the Bezier curve functions; they are maintained in a separate project (jsBezier)</p>
					</li>
				</ul>
			These four files are packaged together to form the scripts that people use, for example:
			<ul>
				<li>jquery.jsPlumb-1.2.4-all.js
				<p>Contains jsPlumb-1.2.4.js, jsPlumb-defaults-1.2.4.js, jquery.jsPlumb-1.2.4.js and jsBezier-0.1.js</p>
				</li>
				<li>jquery.jsPlumb-1.2.4-all-min.js
				<p>A minified version of the script above (minified using Google's Closure minifier)</p>
				</li>
			</ul>
			<h4><a id="pluggableLibrarySupport">Pluggable Library Support</a></h4>
		Out of the box, jsPlumb can be run on top of jQuery or MooTools.  This is achieved by
		delegating several core methods - tasks such as finding an element by id, finding an element's
		position or dimensions, initialising a draggable, etc - to the library in question.
		<p>To develop one of these, your test page should include the first two scripts discussed above, and
		then your own script containing your library specific functionality.  The two existing implementations
		should be documented well enough for you to create your own.  If you do this, it would be
		great to share it with everyone...</p>   
		</div>

		<form action="https://www.paypal.com/cgi-bin/webscr" method="post">
			<input type="hidden" name="cmd" value="_s-xclick">
			<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----MIIHNwYJKoZIhvcNAQcEoIIHKDCCByQCAQExggEwMIIBLAIBADCBlDCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20CAQAwDQYJKoZIhvcNAQEBBQAEgYBej5GBsAnmXAM9h0ChYPYskUnNnkwNL/DSFA3+YYGKERtfJG+i6mQU1wj+O79IT+d948PhghTq4Ey2gKFOx7jglVk8ZYvV4qnp4JxHffW+rUcz1giDOzTyPEhsSAdCZcrRDgMfP3z4GZiOvdrWGevqHPK17SS15ew22LYv0ozV7jELMAkGBSsOAwIaBQAwgbQGCSqGSIb3DQEHATAUBggqhkiG9w0DBwQIb7j74OvPGSqAgZBV62LRvUgjx8WJEq0ov7FzVEbJY/f55tujRCyHydjLCZw+OwMhg7LNItgtICd67jUwWDySNfF4jPv+F/5azlFriyBgHeroli0SH+Yj3hEJeuOATa8WStbOdZtICyUTgnYHdD780XfNkZ4pmphPYB74LEjZrgdUAFuoWEVqJYlyzx3wGv9Vn2JA0yrOLPGdJ3KgggOHMIIDgzCCAuygAwIBAgIBADANBgkqhkiG9w0BAQUFADCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20wHhcNMDQwMjEzMTAxMzE1WhcNMzUwMjEzMTAxMzE1WjCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMFHTt38RMxLXJyO2SmS+Ndl72T7oKJ4u4uw+6awntALWh03PewmIJuzbALScsTS4sZoS1fKciBGoh11gIfHzylvkdNe/hJl66/RGqrj5rFb08sAABNTzDTiqqNpJeBsYs/c2aiGozptX2RlnBktH+SUNpAajW724Nv2Wvhif6sFAgMBAAGjge4wgeswHQYDVR0OBBYEFJaffLvGbxe9WT9S1wob7BDWZJRrMIG7BgNVHSMEgbMwgbCAFJaffLvGbxe9WT9S1wob7BDWZJRroYGUpIGRMIGOMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFjAUBgNVBAcTDU1vdW50YWluIFZpZXcxFDASBgNVBAoTC1BheVBhbCBJbmMuMRMwEQYDVQQLFApsaXZlX2NlcnRzMREwDwYDVQQDFAhsaXZlX2FwaTEcMBoGCSqGSIb3DQEJARYNcmVAcGF5cGFsLmNvbYIBADAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA4GBAIFfOlaagFrl71+jq6OKidbWFSE+Q4FqROvdgIONth+8kSK//Y/4ihuE4Ymvzn5ceE3S/iBSQQMjyvb+s2TWbQYDwcp129OPIbD9epdr4tJOUNiSojw7BHwYRiPh58S1xGlFgHFXwrEBb3dgNbMUa+u4qectsMAXpVHnD9wIyfmHMYIBmjCCAZYCAQEwgZQwgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tAgEAMAkGBSsOAwIaBQCgXTAYBgkqhkiG9w0BCQMxCwYJKoZIhvcNAQcBMBwGCSqGSIb3DQEJBTEPFw0xMDExMjUxMjU3MDFaMCMGCSqGSIb3DQEJBDEWBBRWPNeGBOQ7miMBRIhceIi40qjTKjANBgkqhkiG9w0BAQEFAASBgBkhuKl0vZrxDziiwX6nesN0yUVvBpfqjHEW05vfD7Cz8hkd1J5pNsOhpMayNdAaGEDKqJYPk8e/yW7JTQmBfx5e+LhkW1racZVsMwgWrBcnDPXhTFLWX/FyXpiU6GpAVCHtdNoLeD4FRKHXRq5HKkdmAhMySa6TfGF43Mc8pRpy-----END PKCS7-----">
			<input type="image" src="https://www.paypal.com/en_US/i/btn/btn_donate_SM.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
			<img alt="" border="0" src="https://www.paypal.com/en_US/i/scr/pixel.gif" width="1" height="1">
		</form>			

		<!-- Start of StatCounter Code -->
<script type="text/javascript">
var sc_project=5700644;
var sc_invisible=1;
var sc_partition=71;
var sc_click_stat=1;
var sc_security="1cb90164";
</script>

<script type="text/javascript"
src="http://www.statcounter.com/counter/counter.js"></script><noscript><div
class="statcounter"><a title="counter for wordpress"
href="http://www.statcounter.com/wordpress.org/"
target="_blank"><img class="statcounter"
src="http://c.statcounter.com/5700644/0/1cb90164/1/"
alt="counter for wordpress" ></a></div></noscript>
<!-- End of StatCounter Code -->
 	</body>
 </html>