<!doctype html>
<html>
	<head>
		<title>jsPlumb - documentation</title>
		<link rel="stylesheet" href="/mp.css"></link>
		<link rel="stylesheet" href="../css/jsPlumbDemo.css"></link>
	</head>
	<body>
		<div class="menu"><a href="../html/demo.html" class="mplink">view demo</a>&nbsp;|&nbsp;<a href="mailto:simon.porritt@gmail.com" class="mplink">contact me</a></div>

	<div class="section">
			<h3>Index</h3>
			<ul>
				<li><a href="#summary">Summary</a></li>
				<li><a href="#basic">Basic Configuration</a></li>
				<li><a href="#unload">Unloading jsPlumb</a></li>
				<li><a href="#upcoming">Upcoming in version 1.1.0</a></li>
				<li><a href="#changes">Changes between 1.0.3 and 1.0.4</a></li>
				<li><a href="#examples">Examples</a></li>
				<li><a href="#repaint">Automatic repaint</a></li>
				<li><a href="#options">Options</a></li>
				<li><a href="#defaults">Defaults</a></li>
				<li><a href="#anchors">Anchors</a></li>
				<li><a href="#connectors">Connectors</a></li>
				<li><a href="#endpoints">Endpoints</a></li>
				<li><a href="#gradients">Gradients</a></li>
				<li><a href="#cssclasses">CSS Class Reference</a></li>
				<li><a href="#enhancements">Future Enhancements</a></li>
			</ul>
			<h2><strong>NOTE: This document refers to release 1.0.4 of jsPlumb. The latest released version is 1.1.0, for which the documentation is not yet complete, but will be published soon. In the meantime the best source for help is to either email me or to look at the two demonstration pages.</strong></h2>
			<strong>06/15/10</strong>
		</div>

		<div class="section">
			<a id="summary"><h3>Summary</h3></a>
			jsPlumb allows you to connect elements on the screen with "plumbing", using a Canvas
			element when supported, and Google's <a class="mplink" href="http://excanvas.sourceforge.net/" target="_blank">ExplorerCanvas</a> script to support older browsers.
			<p>
			It's written as a jQuery plugin, and relies on jQuery 1.3.x or jQuery 1.4.x (tested on 1.3.2 and 1.4.2), and also jQuery UI 1.7.2 or 1.8.0 (if you want to support
			dragging).  For Canvas support in IE you also need to include Google's ExplorerCanvas script.
			</p>
			<p>jsPlumb has been tested on the following browsers:
				<ul>
					<li>IE 6 on Windows XP</li>
					<li>IE 7 on Windows XP</li>
					<li>IE 8 on Windows XP (we force IE7 standards compatibility mode)</li>
					<li>Firefox 3.5.8 on Windows XP</li>
					<li>Firefox 3.6 on Ubuntu 9.10</li>
					<li>Firefox 3.6 on Windows XP</li>
					<li>Chrome on Ubuntu 9.10</li>
					<li>Safari 4 on Mac Tiger</li>
					<li>Safari 4 on Windows XP</li>
					<li>Opera 10.5 on Windows XP</li>
				</ul>
			</p>
		</div>

		<div class="section">
			<a id="basic"><h3>Basic configuration</h3></a>
			To use jsPlumb you need jQuery 1.3.x or 1.4.x, jQueryUI 1.7.x or 1.8.x, and ExplorerCanvas:
			<div class="code">
			<pre>&lt;script type="text/javascript" src="http://explorercanvas.googlecode.com/svn/trunk/excanvas.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.7.2/jquery-ui.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="PATH_TO/jquery.jsPlumb-1.0.4-min.js "&gt;&lt;/script&gt;</pre>
			</div>

			<a id="unload"><h3>Unloading jsPlumb</h3></a>
			jsPlumb offers a method you can call when your page is unloading.  You should do this to insure
			against memory leaks.  You configure it like this:
				<div class="code">
<pre>
&lt;body onunload="jsPlumb.unload();"&gt;

...

&lt;/body&gt;
</pre>
				</div>
		</div>

		<div class="section">
			<a id="upcoming"><h3>Upcoming in version 1.1.0</h3></a>
			<ul>
				<li>a first pass at edit support - the ability to drag and drop endpoints, and to draw new connections from existing endpoints.</li>
				<li>a better demonstration of how to write your own type of connecting plumb line</li>
			</ul>

			<a id="changes"><h3>Changes between 1.0.3 AND 1.0.4</h3></a>
			<ul>
				<li>added setDraggable method to jsPlumb.  overrides what any given plumb command may request.</li>
				<li>added setDraggableByDefault method.</li>
				<li>added jsPlumb.Endpoints.Blank Endpoint type.</li>
			</ul>
		</div>

		<div class="section">
			<a id="examples"><h3>Examples</h3></a>

			The basic syntax of a call is that you execute 'plumb' on some element, providing a target, and optionally a paintStyle and preferences for where you
			want the plumbing to be anchored on each element, as well as the type of connector to use:

			<ul>
				<li>Plumb window1 to window2 with the default settings:
					<div class="code">
						<pre>$("#window1").plumb({target:'window2'});</pre>
					</div>
				</li>
				<li>Plumb window1 to window2 with a 15 pixel wide yellow plumb line, and a slightly brighter endpoint:
					<div class="code">
<pre>$("#window1").plumb({
	target:'window2',
	paintStyle:{lineWidth:15,strokeStyle:'rgb(243,230,18)'},
	endpointStyle:{fillStyle:'rgb(243,229,0)'}
});</pre>
					</div>
				</li>
				<li>Plumb window3 to 'window4' with a 10 pixel wide, semi opaque blue plumb line, anchored to the left middle of window3, and the right middle of window4, with an endpoint of radius 25:
					<div class="code">
<pre>$("#window3").plumb({
	target:'window4',
	paintStyle:{lineWidth:10, strokeStyle:'rgba(0, 0, 200, 0.5)'},
	anchors:[jsPlumb.Anchors.RightMiddle, jsPlumb.Anchors.LeftMiddle],
	endpointStyle:{radius:25}
});</pre>
					</div>
				</li>
				<li>Plumb window2 to window3 with a default plumb line from the top center of window2 to the bottom center of window3, and rectangular endpoints:
					<div class="code">
<pre>$("#window2").plumb({
	target:'window3',
	paintStyle:{lineWidth:8, strokeStyle:'rgb(189,11,11)'},
	anchors:[jsPlumb.Anchors.BottomCenter, jsPlumb.Anchors.TopCenter],
	endpointType:new jsPlumb.Endpoints.Rectangle()
});</pre>
					</div>
				</li>


				<li>Plumb window1 to window2 with a 15 px wide yellow Bezier. endpoints are a slightly lighter shade of yellow.
<div class="code">
<pre>$("#window1").plumb({
	target:'window2',
	anchors:[jsPlumb.Anchors.BottomCenter, jsPlumb.makeAnchor(0.75,0,0,-1)],
	paintStyle:{lineWidth:15,strokeStyle:'rgb(243,230,18)'},
	endpointStyle:{fillStyle:'rgb(243,229,0)'}
});</pre>
</div></li>
<li>Plumb window3 to window4 with a 10px wide blue-ish half transparent Bezier. put endpoints underneath the element they attach to.
the endpoints have a radial gradient. both ways of specifying gradient positioning are shown here.
<div class="code">
<pre>var w34Stroke = 'rgba(50, 50, 200, 1)';
var w34HlStroke = 'rgba(180, 180, 200, 1)';
$("#window3").plumb(
	{target:'window4',
		 paintStyle:{lineWidth:10, strokeStyle:w34Stroke},
		 anchors:[jsPlumb.Anchors.RightMiddle, jsPlumb.Anchors.LeftMiddle],
		 endpointStyle:{ gradient : {stops:[[0, w34Stroke], [1, w34HlStroke]], offset:17.5, innerRadius:15 }, radius:35},
		 //endpointStyle:{ gradient : {stops:[[0, w34Stroke], [1, w34HlStroke]], offset:'78%', innerRadius:'73%'}, radius:35 },
		 endpointsOnTop:false
	}
);</pre>
</div></li>
<li>Plumb window2 to window3 with an 8px red Bezier and default rectangular endpoints.  see also how the first anchor is
specified here - this is how you create anchors in locations jsPlumb does not offer shortcuts for.
the endpoints in this example have linear gradients applied.
<div class="code">
<pre>var w23Stroke = 'rgb(189,11,11)';
$("#window2").plumb({
	target:'window3',
	paintStyle:{lineWidth:8,strokeStyle:w23Stroke},
	anchors:[jsPlumb.makeAnchor(0.3,1,0,1), jsPlumb.Anchors.TopCenter],
	endpoint:new jsPlumb.Endpoints.Rectangle(),
	endpointStyles:[{ gradient : {stops:[[0, w23Stroke], [1, '#558822']] }},
       				{ gradient : {stops:[[0, w23Stroke], [1, '#882255']] }}]
});</pre>
</div></li>

<li>Plumb window5 to window6 from center to center, 5px wide line that is green and half transparent. the endpoints are
125px in radius and spill out from underneath their elements.
<div class="code">
<pre>$("#window5").plumb({
	target:'window6',
	anchors:[jsPlumb.Anchors.Center, jsPlumb.Anchors.Center],
	paintStyle:{lineWidth:5,strokeStyle:'rgba(0,255,0,0.5)'},
	endpointsOnTop:false,
	endpointStyle:{radius:125}
});</pre>
</div></li>

<li>Plumb window4 to window5 from bottom right to top left, with a 7px straight line purple connector, and an image as the endpoint,
placed on top of the element it is connected to.
<div class="code">
<pre>$("#window4").plumb({
	target:'window5',
	anchors:[jsPlumb.Anchors.BottomRight,jsPlumb.Anchors.TopLeft],
	paintStyle:{lineWidth:7,strokeStyle:'rgb(131,8,135)'},
	endpoint:new jsPlumb.Endpoints.Image({url:"http://morrisonpitt.com/jsPlumb/img/endpointTest1.png"}),
	connector:new jsPlumb.Connectors.Straight(),
	endpointsOnTop:true
});</pre>
</div></li>


				<li>Plumb window5 to window6 between their center points with a semi-opaque connector, and 125px endpoints:
					<div class="code">
<pre>$("#window5").plumb({
	target:'window6',
	anchors:[jsPlumb.Anchors.Center, jsPlumb.Anchors.Center],
	paintStyle:{lineWidth:5,strokeStyle:'rgba(0,255,0,0.5)'},
	endpointsOnTop:false,
	endpointStyle:{radius:125}
});</pre>
					</div>
				</li>
				<li>Plumb window7 to window8 with a 10 pixel wide blue plumb line, anchored on the top left of window7 and the bottom right of window8, and
				   disable dragging (if any other plumb command enables dragging on either element this will be overridden):
					<div class="code">
<pre>$("#window7").plumb({
	target:'window8',
	paintStyle:{lineWidth:10, strokeStyle:'blue'},
	anchors:[jsPlumb.Anchors.TopLeft, jsPlumb.Anchors.BottomRight]
});</pre>
					</div>
				</li>
				<li>Plumb the bottom right corner of window4 to the top left corner of window5, with rectangular endpoints of size 40x40 that appear below the content elements:
					<div class="code">
<pre>$("#window4").plumb({
	target:'window5',
	anchors:[jsPlumb.Anchors.BottomRight,jsPlumb.Anchors.TopLeft],
	paintStyle:{lineWidth:7,strokeStyle:'rgb(131,8,135)'},
	endpointsOnTop:false,
	endpointStyle:{width:40, height:40},
	endpointType:new jsPlumb.Endpoints.Rectangle(),
	connector:new jsPlumb.Connectors.Straight()
});</pre>
					</div>
				</li>
				<li>Plumb window1 to window2 with the default paint settings but provide some drag options (which are passed through to jQuery's draggable call):
					<div class="code">
						<pre>$("#window1").plumb({target:'window2', dragOptions:{cursor:'crosshair'}});</pre>
					</div>
				</li>
				<li>Detach window2 from window1
					<div class="code">
						<pre>$("#window2").detach("window1");</pre>
					</div>
				</li>
				<li>Detach window2 from window1 and window3
					<div class="code">
						<pre>$("#window2").detach(["window1", "window3"]);</pre>
					</div>
				</li>
				<li>Detach window5 from all connections
					<div class="code">
						<pre>$("#window5").detachAll();</pre>
					</div>
				</li>
				<li>Hide all window5's connections
					<div class="code">
						<pre>jsPlumb.hide("window5");</pre>
					</div>
				</li>
				<li>Show all window5's connections
					<div class="code">
						<pre>jsPlumb.show("window5");</pre>
					</div>
				</li>
				<li>Toggle the visibility of window5's connections
					<div class="code">
						<pre>jsPlumb.toggle("window5");</pre>
					</div>
				</li>
				<li>Force repaint of all of window5's connections
					<div class="code">
						<pre>jsPlumb.repaint("window5");</pre>
					</div>
				</li>
				<li>Force repaint of all of window5, window6 and window11's connections
					<div class="code">
						<pre>jsPlumb.repaint( [ "window5", "window6", "window11" ] );</pre>
					</div>
				</li>
				<li>Force repaint of every connection
					<div class="code">
						<pre>jsPlumb.repaintEverything();</pre>
					</div>
				</li>
				<li>Detach every connection
					<div class="code">
						<pre>jsPlumb.detachEverything();</pre>
					</div>
				</li>
				<li>Set window1 to be not draggable, no matter what some plumb command may request.
					<div class="code">
						<pre>jsPlumb.setDraggable("window1", false);</pre>
					</div>
				</li>
				<li>Set window1 and window2 to be not draggable, no matter what some plumb command may request.
					<div class="code">
						<pre>jsPlumb.setDraggable(["window1","window2"], false);</pre>
					</div>
				</li>
				<li>Sets whether or not elements that are plumbed are draggable by default.
				The default for this is true.
					<div class="code">
						<pre>jsPlumb.setDraggableByDefault(false);</pre>
					</div>
				</li>
			</ul>
		</div>

		<div class="section">
			<a id="repaint"><h3>Automatic Repaint</h3></a>
			jsPlumb attaches a listener to the browser window and automatically repaints every connection
			when a window resize event occurs.  You can disable this functionality, if you want to, with
			the following call:
<div class="code">
<pre>jsPlumb.setAutomaticRepaint(false);</pre>
</div>
You can also provide your own function for jsPlumb to execute instead of its default behaviour:
<div class="code">
<pre>var repaint = function() {
	// do some things, perhaps, and then...
	jsPlumb.repaintEverything();
};

jsPlumb.setRepaintFunction(repaint);</pre>
</div>
Notice the call to <strong>repaintEverything()</strong> here - a useful method.
<p>Another example"</p>
<div class="code">
<pre>var repaint = function() {
	// completely start over
	jsPlumb.detachEverything();
	// paint all your connections
};

jsPlumb.setRepaintFunction(repaint);</pre>
</div>
		</div>

		<div class="section">
			<a id="options"><h3>Options</h3></a>
			<p>These are the options you can specify on a call to the plumb method:</p>
			<ul>
				<li><strong>target</strong>
					<p>This is a required argument.  It identifies the target element for the plumb.</p>
				</li>
				<li><strong>paintStyle</strong>
					<p>Optional; if not supplied jsPlumb uses the values defined in jsPlumb.DEFAULT_PAINT_STYLE (see <a href="#defaults">defaults</a>). This object allows you to specify five attributes of the connector:
						<ul>
							<li>strokeStyle	- the color used to paint the connector.  NOTE: jsPlumb does not yet support patterns.</li>
							<li>lineWidth - the width of the connector in pixels</li>
							<li>lineCap - how the end of the line will be capped.</li>
							<li>miterLimit - the limit on how mitery the miters can miterate.</li>
							<li>gradient - you can specify a set of colors to use as a gradient for the Connector. see <a href="#gradients">Gradients</a></li>
						</ul>
					</p>
					<p>
					The arguments to the strokeStyle parameter can be anything that is a valid argument for the strokeStyle parameter of HTML Canvas element, which
					are CSS colors, patterns or gradients.
					</p>
					<p>
					This is the <a class="mplink" href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html" target="_blank">working group's page for the Canvas element</a>, where you can find information
					on painting in Canvas.
					</p>
					<p>
					Mozilla also has some good documentation <a class="mplink" href="https://developer.mozilla.org/en/Canvas_tutorial/Applying_styles_and_colors" target="_blank">here</a>
					</p>
				</li>
				<li><strong>connector</strong>
					<p>Optional; if not supplied jsPlumb uses a Bezier connector (see <a href="#defaults">defaults</a>)</p>
					<p>Valid values for this are:
						<ul>
							<li>new jsPlumb.Connectors.Straight (optional_params) - a straight line directly connecting two anchors</li>
							<li>new jsPlumb.Connectors.Bezier (optional_curviness_value) - a Bezier curve connecting two anchors.</li>
						</ul>
					</p>
					<p>You can also supply your own Connector implementation; for details on how to write a Connector see
					the <a href="#connectors">Connectors</a> section below.</p>
				</li>
				<li><strong>anchors</strong>
					<p>Optional; if not supplied jsPlumb uses <strong>[ jsPlumb.Anchors.BottomCenter, jsPlumb.Anchors.TopCenter ]</strong>  (see <a href="#defaults">defaults</a>)</p>
					<p>If you supply this, it must be in the form of a list with two elements - the first element is
					the anchor type for the source element (the one on which you are calling the 'plumb' method), and the
					second is the anchor type for the target element.
					</p>
					<p>Valid values for this are any Anchor you have created yourself (see the <a href="#anchors">anchors</a> section below), or one
					of these default anchors provided by jsPlumb:
						<ul>
							<li>jsPlumb.Anchors.TopCenter</li>
							<li>jsPlumb.Anchors.TopRight</li>
							<li>jsPlumb.Anchors.RightMiddle</li>
							<li>jsPlumb.Anchors.BottomRight</li>
							<li>jsPlumb.Anchors.BottomCenter</li>
							<li>jsPlumb.Anchors.BottomLeft</li>
							<li>jsPlumb.Anchors.LeftMiddle</li>
							<li>jsPlumb.Anchors.TopLeft</li>
							<li>jsPlumb.Anchors.Center</li>
						</ul>
					</p>
					<p>The locations of these are hopefully self-explanatory.  You can supply your own Anchor implementations if you need to - see the section on <a href="#anchors">Anchors</a></p>
				</li>
				<li><strong>endpoint</strong>
					<p>Optional; if not supplied jsPlumb uses <strong>jsPlumb.Endpoints.Dot</strong>, with the default size of 10  (see <a href="#defaults">defaults</a>).</p>
					<p>Valid values for this are:
						<ul>
							<li>new jsPlumb.Endpoints.Dot ( optional_params )</li>
							<li>new jsPlumb.Endpoints.Rectangle ( optional_params ) </li>
							<li>new jsPlumb.Endpoints.Image (url) </li>
						</ul>
					</p>
					<p>Similar to Connectors and Anchors, you can provide your own Endpoint implementation; see the <a href="#endpoints">Endpoints</a> section.</p>
				</li>
				<li><strong>endpoints</strong>
					<p>Optional; this is similar to <strong>endpoint</strong> but should be used when you want to specify a different Endpoint for each end of the Connector.</p>
					<p>This should be supplied as a list, for example:
<div class="code">
<pre>endpoints:[ { ..endpoint1.. }, { ..endpoint2.. } ]</pre>
</div>
					</p>
				</li>
				<li><strong>endpointStyle</strong>
					<p>Optional; if not supplied jsPlumb uses the values defined in <strong>jsPlumb.DEFAULT_ENDPOINT_STYLE</strong>  (see <a href="#defaults">defaults</a>).</p>
					<p>This Javascript object allows you to specify the following arguments for the Endpoint:
						<ul>
							<li>fillStyle - the color to fill the endpoint with.</li>
							<li>gradient - you can specify a set of colors to use as a gradient for the Endpoint. see <a href="#gradients">Gradients</a></li>
						</ul>
						<br />
					</p>
				</li>
				<li><strong>endpointStyles</strong>
					<p>Optional; this is similar to <strong>endpointStyle</strong> but should be used when you want to specify a different style for each of the two Endpoints.</p>
					<p>This should be supplied as a list, for example:
<div class="code">
<pre>endpointStyles:[ { ..style1.. }, { ..style2.. } ]</pre>
</div>
					</p>
				</li>
				<li><strong>endpointsOnTop</strong>
					<p>This is a boolean value that defaults to true.  When true, it forces jsPlumb to set the z-index of endpoints
						to be 1 more than that of the element to which they belong.  This is perhaps not the most awesome thing.
						Something tells me a better way to manage all of this is in CSS (see the <a href="#connectors">connectors</a>,
						<a href="#endpoints">endpoints</a> and <a href="#anchors">anchors</a> sections for information on what CSS classes
						jsPlumb uses).
					</p>
				</li>
				<li><strong>drawEndpoints</strong>
					<p>This is a boolean value that defaults to true.</p>
				</li>
				<li><strong>dragOptions</strong>
					<p>
						You can provide your own set of dragOptions to pass through to the call to jQuery's draggable(..) function if you need to. jsPlumb will wrap any drag
						method you provide, since it needs to be aware of drag activity, but everything else is passed through as you specify it. You can do this either on
						each call you make:
						<div class="code">
							<pre>$("#someWindow").plumb({target:"otherWindow", dragOptions:{cursor: 'crosshair'}});</pre>
						</div>
				 		or for convenience you might want to override the defaults:
						<div class="code">
							<pre>jsPlumb.DEFAULT_DRAG_OPTIONS = { .. your drag options here. };</pre>
						</div>
						Consult <a class="mplink" target="_blank" href="http://docs.jquery.com/UI/Draggable">the jQuery documentation</a> for more information on what you can pass as drag options.</p>
					</p>
				</li>
			</ul>


		</div>

		<div class="section">
			<a id="defaults"><h3>Defaults</h3></a>
			The easiest way to set a look and feel for your plumbing is to override the defaults that jsPlumb uses. If you
			do not do this you are forced to provide your overridden values on every call.  Every argument to the plumb method has an
			associated default value in jsPlumb.<br/><br/>

			The defaults that ship with jsPlumb are:

			<div class="code">
<pre>DEFAULT_PAINT_STYLE : {
    lineWidth : 10,
    strokeStyle : "red"
}

DEFAULT_DRAG_OPTIONS : { }

DEFAULT_ENDPOINT_STYLE : { fillStyle : null; }

DEFAULT_ENDPOINT_STYLES : [ null, null ]

DEFAULT_ANCHORS : [ jsPlumb.Anchors.BottomCenter, jsPlumb.Anchors.TopCenter ]

DEFAULT_CONNECTOR : jsPlumb.Connectors.Bezier;

DEFAULT_ENDPOINT : jsPlumb.Endpoints.Dot;

DEFAULT_ENDPOINTS : [jsPlumb.Endpoints.Dot, jsPlumb.Endpoints.Dot];
</pre>
			</div>
			<p>
			Note that in DEFAULT_ENDPOINT_STYLE, the default fillStyle is 'null'.  This instructs jsPlumb to use the strokeStyle
from the attached connector to fill the endpoint.</p>
<p>Note also that you can specify either or both (or neither) of 'DEFAULT_ENDPOINT_STYLE' and 'DEFAULT_ENDPOINT_STYLES'.  This allows you to specify a different
end point for each end of a connection.  'DEFAULT_ENDPOINT' and 'DEFAULT_ENDPOINTS' use the same concept.  jsPlumb will look first in the
individual endpoint/endpoint style arrays, and then fall back to the single default version.</p>

			you can override these defaults by including this in a script somewhere:
			<div class="code">
<pre>
jsPlumb.DEFAULT_PAINT_STYLE = {
	lineWidth:13,
	strokeStyle: 'rgba(200,0,0,100)'
}

jsPlumb.DEFAULT_DRAG_OPTIONS = { cursor: 'crosshair' };

jsPlumb.DEFAULT_ENDPOINTS = [ new jsPlumb.Endpoints.Dot(7), new jsPlumb.Endpoints.Dot(11) ]

jsPlumb.DEFAULT_ENDPOINT_STYLES = [{ fillStyle:'#225588' }, { fillStyle:'#558822' }];
</pre>
			</div>
			after the jsPlumb script has been loaded of course!  Here we have specified the following default behaviour:
			<ul>
				<li>connectors are 13 pixels wide and painted with a semi-transparent red line</li>
				<li>when dragging an element the crosshair cursor is used</li>
				<li>the source endpoint is a dot of radius 7; the target endpoint is a dot of radius 11</li>
				<li>the source endpoint is blue; the target endpoint is green</li>
			</ul>

		</div>

		<div class="section">
			<a id="anchors"><h3>Anchors</h3></a>
			<p>An Anchor models the notion of where on an element a plumb line should connect.  jsPlumb has nine default anchor locations you
			can use to specify where the plumb lines connect to elements: these are the four corners of an element,
			the center of the element, and the midpoint of each edge of the element.</p>
			<p>You can provide your own anchor locations if you need to.  jsPlumb supports two ways of doing this:
				<ul>
					<li>jsPlumb.makeAnchor(x, y, xOrientation, yOrientation, xOffset, yOffset) function
					<p>
					This function creates a basic Anchor of the type that jsPlumb uses internally, which is a statically located anchor whose
					position is specified by providing a fractional distance for both x and y.  For instance, the TopCenter anchor in jsPlumb
					is situated at [0, 0.5].
					</p>
					A call to jsPlumb.makeAnchor should look something like this:
<div class="code">
<pre>
var myAnchor = jsPlumb.makeAnchor( 0.333, 0.5, 0, 1 );
</pre>
</div>
					<p>
					Here we have specified an anchor that will be located at a point which is one-third of the width of the element, and half its height.  The orientation array indicates that the natural flow of connectors from this element is unspecified for the x direction, but straight down the page in the y direction.
					</p>
					The arguments are:
					<ul>
						<li>x - required. decimal value indicating proportional location with respect to width of the element. 0 is left. 1 is full width.  note that you can use any numbers here, even outside of the 0-1 range.  </li>
						<li>y - required. decimal value indicating proportional location with respect to height of the element. 0 is left. 1 is full height.  note that you can use any numbers here, even outside of the 0-1 range.  </li>
						<li>xOrientation - optional, defaults to 0.  Defines the x hint for the general direction in which connectors leaving the anchor should travel.  Valid values are 0, 1, or -1.</li>
						<li>yOrientation - optional, defaults to 0.  Defines the y hint for the general direction in which connectors leaving the anchor should travel.  Valid values are 0, 1, or -1.</li>
						<li>xOffset - optional, defaults to 0.  Optional absolute pixel value offset to apply once the relative positioning has been performed.</li>
						<li>yOffset - optional, defaults to 0.  Optional absolute pixel value offset to apply once the relative positioning has been performed.</li>
					</ul>
					<br/>
					</li>
					<li>Providing your own anchor function
					<p>
					For most cases, the jsPlumb.makeAnchor function will probably suffice.  But the method signature of the <em>compute</em> function
					of an anchor takes the location of <strong>both elements</strong>, meaning it is possible to write an anchor whose position takes
					into account where the current element is in relation to the one it is plumbed to.  jsPlumb does not natively do this but it
					seems like something that might be useful.
					</p>
					<p>An anchors function consists of two parts - a function that computes the location of the anchor, given the current xy and width/height of the source
					element and target element, plus an 'orientation' array, which gives jsPlumb hints
					about which way plumb lines should flow into and out of the anchor point.  Not every Connector implementation
					will use this orientation array - the Straight Connector, for instance, ignores it completely, because it just
					directly connects the two anchor points.
					</p>
					<p>
			To provide your own anchor location you can either set it in amongst the defaults:
			<div class="code">
<pre>
jsPlumb.Anchors.MyAnchor = {
	compute : function(xy, wh, txy, twh) { 	// do some maths and return an [x,y] location }
	orientation : [ox, oy]       	// each value can be one of -1, 0 or 1. 0 means dont care,
								 	// 1 or -1 means go in this direction in this plane.
};
</pre>
			</div>
			or you can create it elsewhere and reference it in your calls:
			<div class="code">
<pre>
var myAnchor =  {
	compute : function(xy, wh, txy, twh) {  	// do some maths and return an [x,y] location }
	orientation : [ox, oy]       	// each value can be one of -1, 0 or 1. 0 means dont care,
									// 1 or -1 means go in this direction in this plane.
};

$("someWindow").plumb({target:'otherWindow', anchors:[myAnchor, myAnchor]});
</pre>
			</div>
			The arguments to the compute function are:
			<ul>
				<li>xy - location (on screen) of the source element's top left corner</li>
				<li>wh - dimensions of the source element</li>
				<li>txy - location (on screen) of the target element's top left corner</li>
				<li>twh - dimensions of the target element</li>
			</ul>
			</p>
			<p>The <em>compute</em> function should return an array of two elements - the [x,y] on screen where the anchor is located.</p>
			<p>
			Examples of the <em>orientation</em> array can be found in the Javascript source.  It is simply a hint to jsPlumb
			of what direction a plumb line leaving the given anchor should _initially_ head in.  So, for example, the TopCenter
			anchor point defines its orientation as [0,-1], meaning "i don't care about x, but i want you to head towards the
			top of the screen as you leave this point".  Take another example - BottomRight.  This is the bottom right corner
			of an element.  It declares its orientation to be [1,1], meaning go down and to the right as you leave this element.
			</p>

					</li>
				</ul>
			</p>

					</div>

		<div class="section">
			<a id="connectors"><h3>Connectors</h3></a>
			Connectors are the lines that actually join elements of the UI.  jsPlumb has two connector implementations - a straight line and a Bezier curve.  The default connector is the Bezier curve.
			<p>jsPlumb attaches the CSS class <em>_jsPlumb_connector</em> to Connectors that it generates.</p>
				<h4><a id="bezierConnector">Bezier Connector</a></h4>
				<p>The Bezier Connector provides a Bezier path between the two endpoints.  You construct one like this:
				<br/><br/>
				var myConnector = new jsPlumb.Connectors.Bezier(curviness);<br/><br/>
				<strong>curviness</strong>, which is optional (and defaults to 150), defines the distance in pixels that
				the Bezier's control points are situated from the anchor points.  This does not mean that your
				connector will pass through a point at this distance from your curve.  It is a hint to how you want the
				curve to travel. Rather than discuss Bezier curves at length here, because they are a very complex topic,
				we refer you to <a href="http://en.wikipedia.org/wiki/B%C3%A9zier_curve" target="_blank">Wikipedia.</a>
				</p>
				<h4><a id="straightConnector">Straight Connector</a></h4>
				<p>The Straight Connector draws a straight line between the two endpoints.  You construct one like this:
				<br/><br/>
				var myConnector = new jsPlumb.Connectors.Straight();<br/><br/>
				</p>
			<p>
			<h4><a id="customConnectors">Custom Connectors</a></h4>
			You can provide your own connectors if you need to. A Connector consists of two functions, which work as a pair.  First a call is made to the <em>compute</em> function:

			<div class="code">
<pre>
this.compute = function(sourcePos, targetPos, sourceAnchor, targetAnchor, lineWidth) {
	...
	return dimensions;
}
</pre>
			</div>
			which is expected to return a list that the <em>paint</em> function can make sense of.  The first four entries in the
			list <strong>must be</strong> the [x,y,width,height] values for the canvas that the connector will be drawn on; jsPlumb will
			use this information to size the canvas prior to calling the Connector's <em>paint</em> function.  Therefore it
			is the Connector's responsibility to ensure that the returned dimensions describe a large enough space for
			the line that will be drawn on it.</p><p>The next four elements <strong>must be</strong> the coordinates of the two endpoints of the line
			you are going to draw.</p><p>The remainder of the items in the returned list are arbitrary, and will
			vary between Connector implementations; this list is passed in to a Connector's <em>paint</em> function, so each
			implementation will put into the list whatever it needs to paint itself.  For instance, the straight line
			connector only needs the [x,y] location of each end of the line it will paint, and that is one of the required entries, so
			it does not have to do anything extra,  whereas the Bezier connector adds the location of the two control points.  Other types of
			Connectors will do whatever is appropriate for their particular situation.
			</p>
			This is the method signature for the <em>paint</em> function:
			<div class="code">
				<pre>this.paint = function(dimensions, ctx) { .. }</pre>
			</div>

			here, the 'dimensions' argument to the 'paint' function is the return value of the 'compute' function.  The 'ctx' argument is the Canvas context; you
			will do all your drawing on this.
			</p>
			To change the connector from the default, specify it in your plumb call:
			<div class="code">
				<pre>$("#someWindow").plumb({target:'otherWindow', connector:new jsPlumb.Connectors.Straight()});</pre>
			</div>
		</div>

		<div class="section">
			<a id="endpoints"><h3>Endpoints</h3></a>
			<p>An Endpoint is the UI component that marks the location of an Anchor, ie. the place where a Connector joins an
			element.  jsPlumb comes with four Endpoint implementations - Blank, Dot, Rectangle and Image.
				<ul>
					<li>jsPlumb.Endpoints.Blank<br/><br/>
						Draws a blank endpoint.  This is a static object; you do not use a constructor. For example, to instruct jsPlumb to use the Blank Endpoint by default, you would make this call:
<div class="code">
<pre>
jsPlumb.DEFAULT_ENDPOINT = jsPlumb.Endpoints.Blank;
</pre>
</div>
					</li>
					<li>jsPlumb.Endpoints.Dot
						<p>This draws a dot.  Example constructor:
<div class="code">
<pre>
var myDot = new jsPlumb.Endpoints.Dot({radius:34});
</pre>
</div>
Here we created a dot with a radius of 34 pixels.  You do not need to supply the radius though - if you omit it, jsPlumb will assign a default of 10 pixels.  Note that you can also supply the radius in the endpointStyle object.
						</p><p>
						In the <em>endpointStyle</em> option of a <em>plumb</em> call, you can set two values
						that this will pick up:
							<ul>
								<li>radius - the radius of the dot (in pixels)</li>
								<li>fillStyle - the style to use when filling the dot.  If this is blank, jsPlumb will
								attempt to use the strokeStyle from the associated Connector.</li>
							</ul>
							<br/>
						</p>
					</li>
					<li>jsPlumb.Endpoints.Rectangle
						<p>Draws a rectangle.  Example constructor:
<div class="code">
<pre>
var myRect = new jsPlumb.Endpoints.Rectangle({width:34, height:10});
</pre>
</div>
Here we created a rectangle of size 34x10.  If you omit the size when you create a Rectangle, jsPlumb will use defaults of 20x20.  Just like with the Dot endpoint, you can also provide this information in the endpointStyle.
</p><p>
						In the <em>endpointStyle</em> you can set the following for this:
							<ul>
								<li>width - optional, defaults to 20.</li>
								<li>height - optional, defaults to 20.</li>
								<li>fillStyle - the style to use when filling the rectangle.  If this is blank, jsPlumb will
								attempt to use the strokeStyle from the associated Connector.</li>
							</ul>
							<br/>
						</p>
					</li>
					<li>jsPlumb.Endpoints.Image
						<p>Draws an image from a given URL.  Example constructor:
<div class="code">
<pre>
var myImage = new jsPlumb.Endpoints.Image({url:"http://myserver.com/images/endpoint.png"});
</pre>
</div>
This creates an Image endpoint with the image at the given url.  You do not need to provide dimensions.  jsPlumb will figure that out for you.
						</p>
					</li>
				</ul>
			</p>
			<p>To create your own Endpoint implementation, you need to implement a single method:
				<div class="code"><pre>paint : function(anchorPoint, orientation, canvas, endpointStyle, connectorPaintStyle) { ... }</pre></div>
				The arguments to this method are as follows:
				<ul>
					<li>anchorPoint - [x,y] location of the anchor point on screen</li>
					<li>orientation - [x,y] hints for the general direction the anchor points to</li>
					<li>canvas - the canvas to draw into</li>
					<li>endpointStyle - Javascript object containing style directives as discussed above.  The contents of this are arbitrary, so if you write a new Endpoint that needs some extra settings, you can add them no hassle.</li>
					<li>connectorPaintStyle - the style being used to paint the associated Connector.</li>
				</ul>
			</p>
			<p>
				It is your responsibility to size and locate the canvas to suit your needs. jsPlumb provides the following
				helper method to assist you:
				<div class="code"><pre>jsPlumb.sizeCanvas(canvas, x, y, width, height);</pre></div>
				Allows you to locate the canvas on screen and to size it.
			</p>
		</div>

		<div class="section">
			<a id="gradients"><h3>Gradients</h3></a>
			The Canvas element supports gradients, and jsPlumb can take advantage of this when painting your Connectors
			and/or Endpoints.  <strong>Note:</strong> this does <strong>NOT WORK in IE</strong>, because we use ExplorerCanvas in IE
			and ExplorerCanvas does not support gradients.
			<p>There are two types of gradients available in Canvas - a 'linear' gradient, which consists of colored lines all
			going in one direction, and a 'radial' gradient, which consists of colored circles emanating from one circle to another.
			Because of their basic shape, jsPlumb supports only <em>linear</em> gradients for
			Connectors.  But for Endpoints, jsPlumb supports both <em>linear</em> and <em>radial</em> gradients.</p>
			<p>
				<h4>Connector gradients</h4>
				To specify a linear gradient to use in a Connector, you must add a <em>gradient</em> object to your
				Connector's <em>paintStyle</em>, for instance:
<div class="code">
<pre>$("#window2").plumb({
	target:'window3',
	paintStyle:{
		gradient:{
			stops:[[0,'green'], [1,'red']]
		},
		lineWidth:15
	}
});
</pre>
</div>
Here we have plumbed window2 to window3 with a 15 pixel wide connector that has a gradient from green to red.</p><p> Notice the <strong>gradient</strong> object and the
<strong>stops</strong> list inside it - the gradient consists of an arbitrary number of these "color stops".  Each color stop is comprised
of two values - [position, color].  Position must be a decimal value between 0 and 1 (inclusive), and indicates where the color
stop is situated as a fraction of the length of the entire gradient.  Valid values for
the colors in the <strong>stops</strong> list are the same as those that are valid for <strong>strokeStyle</strong> when describing a color.
			</p>
			<p>As mentioned, the <strong>stops</strong> list can hold an arbitrary number of entries.  Here's an example of a gradient that goes from red to blue to green, and back again through blue to red:
<div class="code">
<pre>$("#window2").plumb({
	target : 'window3',
	paintStyle : {
		gradient:{
			stops:[[0,'red'], [0.33,'blue'], [0.66,'green'], [0.33,'blue'], [1,'red']]
		},
		lineWidth : 15
	}
});
</pre>
</div>
<strong>Note:</strong> jsPlumb uses ExplorerCanvas for IE, which does not support gradients.  On IE, jsPlumb will simply ignore the gradient directive
so it is best to ensure you also supply a <em>strokeStyle</em> in your paintStyle object, to give jsPlumb something to fall back on.  If you do not supply
a <em>strokeStyle</em> your Connectors will be painted black.  The previous example might look like this, for instance:
<div class="code">
<pre>
$("#window2").plumb({
	target:'window3',
	paintStyle:{
		strokeStyle:'red',
		gradient:{
			stops:[[0,'red'], [0.33,'blue'], [0.66,'green'], [0.33,'blue'], [1,'red']]
		},
		lineWidth:15
	}
});
</pre>
</div>
Notice the <strong>strokeStyle:'red'</strong> directive at the beginning of the parameter list in <strong>paintStyle</strong>.
			</p>
			<h4>Endpoint gradients</h4>
			Endpoint gradients are specified using the same syntax as Connector gradients.  You put the gradient specifier either in the
			<strong>endpoint</strong> member, or if you are specifying different Endpoints for each end of the Connector, in one or both of
			the values in the <strong>endpoints</strong> array.
			<p>
			This is an example of an Endpoint gradient that is different for each Endpoint in the Connector.  This comes from the main demo; it is
			the Connector joining Window 2 to Window 3:
			</p>
<div class="code">
<pre>var w23Stroke = 'rgb(189,11,11)';
$("#window2").plumb({
	target:'window3',
	paintStyle:{
		lineWidth:8,
		strokeStyle:w23Stroke
	},
 	anchors:[ jsPlumb.makeAnchor(0.3,1,0,1), jsPlumb.Anchors.TopCenter ],
 	endpoint:new jsPlumb.Endpoints.Rectangle(),
 	endpointStyles:[
 		{ gradient : {stops:[[0, w23Stroke], [1, '#558822']] } },
    	{ gradient : {stops:[[0, w23Stroke], [1, '#882255']] } }
    ]
});
</pre>
</div>
The first entry in the gradient will be the one that is on the Connector end of the Endpoint.  You can of course have as many color stops as
you want in this gradient, just like with Connector gradients.
	<h5>Applying the gradient in Endpoints</h5>
	Only the Dot and Rectangle endpoints honour the presence of a gradient (and, remember, not in IE). The Image endpoint of course ignores a gradient
	as it does no painting of its own.
	<p>The type of gradient you will see depends on the Endpoint type:
		<ul>
			<li>Dot - renders a radial endpoint, with color stop 0 on the outside, progressing inwards as we move through color stops.
			<p>Radial gradients actually require more data than linear gradients - in a linear gradient we just move from one point to another, whereas
			in a radial gradient we move from one <em>circle</em> to another.  By default, jsPlumb will render a radial gradient using a source
			circle of the same radius as the Endpoint itself, and a target circle of 1/3 of the radius of the Endpoint (both circles share the
			same center as the Endpoint itself). This circle will be offset by radius/2 in each direction.</p>
			<p>You can supply your own values for these inside the gradient descriptor:</p>
<div class="code">
<pre>var w34Stroke = 'rgba(50, 50, 200, 1)';
var w34HlStroke = 'rgba(180, 180, 200, 1)';
$("#window3").plumb({
	target:'window4',
    paintStyle:{
    	lineWidth:10,
    	strokeStyle:w34Stroke
    },
    anchors:[ jsPlumb.Anchors.RightMiddle, jsPlumb.Anchors.LeftMiddle ],
    endpointStyle:{
    	gradient : {
    		stops:[ [0, w34Stroke], [1, w34HlStroke] ],
    		offset:37.5,
    		innerRadius:40
    	},
    	radius:55
    },
    endpointsOnTop:false
 });
</pre>
</div>
Here we have instructed jsPlumb to make the gradient's inner radius 10px instead of the default 25/3 = 8 ish pixels, and the offset in each direction
will be 5px, instead of the default radius / 2 = 12.5 pixels.
<p>It is also possible to specify the offset and inner radius as percentages - enter the values as strings with a '%' symbol on the end:</p>
<div class="code">
<pre>var w34Stroke = 'rgba(50, 50, 200, 1)';
var w34HlStroke = 'rgba(180, 180, 200, 1)';
$("#window3").plumb({
	target:'window4',
    paintStyle:{
    	lineWidth:10,
    	strokeStyle:w34Stroke
    },
	anchors:[ jsPlumb.Anchors.RightMiddle, jsPlumb.Anchors.LeftMiddle ],
	endpointStyle:{
		gradient : {
			stops:[ [0, w34Stroke], [1, w34HlStroke] ],
			offset:'68%',
			innerRadius:'73%'
		},
		radius:25
	},
	endpointsOnTop:false
});
</pre>
</div>
This will give roughly the same output as the example above (the percentages are not entirely exact).
			</li>
			<li>Rectangle - renders a linear endpoint, with color stop 0 closest to the end of the Connector</li>
		</ul>
	</p>
		</div>

		<div class="section">
			<a id="cssclasses"><h3>CSS Class Reference</h3></a>
			jsPlumb attaches classes to each of the UI components it creates:
			<table>
				<tr><th>component</th><th>css class</th></tr>
				<tr><td>connector</td><td>_jsPlumb_connector</td></tr>
				<tr><td>endpoint</td><td>_jsPlumb_endpoint</td></tr>
			</table>
		</div>


		<div class="section">
			<a id="enhancements"><h3>Possible Future Enhancements</h3></a>
			<ul>
				<li>Support locking a given element so that it is never draggable,regardless of
					what a particular plumb command may request. This is targetted for 1.0.4.
				</li>
				<li>Support dragging of connectors - both existing connections and also the
				ability to drag a new connection from an existing endpoint.  This is targetted for
				release 1.1.0.
				</li>
				<li>Support Patterns in both Endpoints and Connectors.
					<p>It is possible to stroke a line in the Canvas element with both gradients and patterns.  Currently jsPlumb supports only
					gradients.</p>
					This work is not currently targetted for any release.
				</li>
				<li>Move the random endpoint-related keys inside the endpointStyle object.  This work is not currently targetted for any release.<br/><br/>
				</li>
				<li>Support an endpoint deriving its color from the color of the element to which it is attached?  This work is not currently targetted for any release.<br/><br/></li>
				<li>Attach DOM listeners so jsPlumb is aware when elements move/change size/disappear/appear etc.  This work is not currently targetted for any release.</li>
			</ul>
		</div>

		<!-- Start of StatCounter Code -->
<script type="text/javascript">
var sc_project=5700644;
var sc_invisible=1;
var sc_partition=71;
var sc_click_stat=1;
var sc_security="1cb90164";
</script>

<script type="text/javascript"
src="http://www.statcounter.com/counter/counter.js"></script><noscript><div
class="statcounter"><a title="counter for wordpress"
href="http://www.statcounter.com/wordpress.org/"
target="_blank"><img class="statcounter"
src="http://c.statcounter.com/5700644/0/1cb90164/1/"
alt="counter for wordpress" ></a></div></noscript>
<!-- End of StatCounter Code -->
 	</body>
 </html>